---
Title: Обработка событий Qt в Kylix-приложении
Author: Андрей Боровский
Date: 01.01.2007
---


Обработка событий Qt в Kylix-приложении
=======================================

::: {.date}
01.01.2007
:::

Автор: Андрей Боровский
([www.kylixportal.chat.ru](https://www.myhomepage.com/index.html))

Что представляют собой события Qt?

Система Windows взаимодействует с приложениями посредством механизма
сообщений, обработка которых осуществляется в оконной функции. В
приложениях, созданных на основе Qt library, сообщения используются
редко, а основным механизмом взаимодействия между приложениями и
системой являются события. Концептуально события Qt очень похожи на
события Kylix. В ответ на событие система вызывает обработчик,
являющийся методом Qt-объекта. Каждому событию в Qt соответствует свой
класс. Обработчику события передается ссылка на экзмпляр класса события,
содержащий необходимую информацию о нем. Для того, чтобы определить
собственный обработчик события для какого-либо Qt класса, следует
создать производный класс этого класса и заместить (override)
метод-обработчик соответствующего события. Однако средства Object Pascal
не позволяют создавать производные классы Qt и замещать их методы,
поэтому в Kylix реализован специальный механизм обработки событий.

События Qt и Kylix

Прежде чем приступить к рассмотрению специальных методов обработки
событий Qt в Kylix, необходимо отметить, что в большинстве случаев у
программиста не возникает необходимости обращаться к этим методам. Для
большинства событий Qt в объектной модели Kylix определены
соответствующие события Kylix, и обработка этих событий может быть
выполнена стандартными средствами Object Pascal. Тем не менее иногда
возникает необходимость ввести в приложении обработку Qt событий, не
определенных в VisualCLX. В CLXDisplay API предусмотрено несколько
механизмов обработки таких событий. В этой статье будет рассмотрен один
из них.

Как и в Delphi, в Kylix приложения строятся на основе класса
TApplication. В Kylix в классе TApplication определено свойство OnEvent,
позволяющее назначать приложению обработчик событий Qt. Обработчик
OnEvent вызывается для каждого события каждого объекта Qt, являющегося
дочерним объектом форм приложения, а также для других событий
приложения.

Тип процедуры обработчика декларируется следующим образом:

procedure (Sender: QObjectH; Event: QEventH; var Handled: Boolean) of
object;

В параметре Sender передается ссылка на объект, который должен
реагировать на событие. Параметр Event является указателем на объект
события. Он позволяет идентифицировать событие и получить информацию о
нем. Переменная Handled позволяет сообщить компоненту Visual CLX о том,
следует ли вызывать обработчик события, определенный в компоненте.

Рассмотрим простой пример: допустим мы хотим, чтобы перерисовка окна
компонента Label1 типа TLabel не выполнялась, если некоторой глобальной
переменной NoRedraw типа Boolean присвоено значение True. для этого
напишем следующую процедуру AppEventHandler:

     uses Qt, ...
     
     ...
     
     procedure TForm1.AppEventHandler(Sender: QObjectH; Event: QEventH; 
     var Handled: Boolean);
     begin
       Handled:=False;                       // Allow  default event processing
       if Sender=Label1.Handle then          // Identify sending Qt object
       if QEvent_isQPaintEvent(Event) then   // Identify the Paint event
       Handled:=NoRedraw;        // Disable or enable default event processing  
     end; 
     
     procedure TForm1.FormCreate(Sender: TObject);
     begin
       ...
       Application.OnEvent:=AppEventHandler;
     end; 
     
     procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
     begin
       ...
       Application.OnEvent:=nil;
     end;

Определить, какому объекту соответствует событие можно, сравнивая
значение Sender с полем Handle экземпляров объектов Kylix. Определенные
в модуле Qt.pas функции QEvent\_isQXXXEvent действуют подобно оператору
is языка Object Pascal и позволяют определить тип события, требующего
обработки. Аргументом этих функций является ссылка на объект QEvent,
являющийся базовым для всех объектов событий. Функция возвращает True,
если ей передан укзатель на объект события соответствующего ей типа и
False в противном случае. Так как любой объект события в Qt является
потомком класса QEvent, после определения типа объекта события мы можем
преобразовать тип значения Event к типу указателя на соответствующий
объект события и при помощи функций CLXDisplay API получить доступ к
методам этого объекта. Переменная Handled служит для того, чтобы
разрешить или запретить дальнейшую обработку события стандартными
средствами. В начале мы устанавливаем значение этой переменной равным
False, для того, чтобы события обрабатывались компонентами. Для того,
чтобы запретить дальнейшую обработку события, нужно присвоить этой
переменной значение True.

Обратите внимание на присвоение значения nil свойству OnEvent в методе
FormClose. Так как время жизни объекта TApplication превышает время
жизни объекта TForm, программа может пытаться вызвать обработчик OnEvent
после уничтожения формы. Если после закрытия формы данное поле не будет
помечено как свободное (unassigned), при выходе из программы возникнет
ошибка сегментации.

Программа, демонстрирующая механизм Drag and Drop

Далее рассматривается небольшое приложение, демонстрирующее перенос
данных между двумя Qt-программами методом Drag and Drop. Средства Drag
and Drop, предоставляемые Kylix, позволяют переносить данные только
между объектами Kylix-приложения, а для того, чтобы осуществлять перенос
между разными приложениями, придется обратиться к методам объектов Qt
library.

Последовательность событий при использовании механизма Drag and Drop
такова: когда пользователь переводит курсор мыши в режиме перетаскивания
в область визуального Qt объекта, являющегося приемником Drag and Drop,
система генерирует событие dragEnterEvent и вызывает обработчик этого
события, определенный в объекте-приемнике. В ответ на это событие объект
должен либо подтвердить выполнение Drag and Drop операции, либо
отказаться от него. Если объект-приемник подтверждает операцию, курсор
мыши приобретает характерный вид "готов к приему объекта" и
пользователь может отпустить кнопку мыши для передачи объекта Drag and
Drop объекту-приемнику. В противном случае курсор принимает вид "прием
Drag and Drop запрещен" и дальнейшие события Drag and Drop не
генерируются. Если объект-приемник разрешил Drag and Drop операцию, при
дальнейшем перемещении мыши над видимой областью соответствующего
интерфейсного элемента генерируется серия событий dragMoveEvent. Если
пользователь отпускает клавишу мыши, генерируется событие DropEvent.
Обработчик этого события должен выполнить непосредственную операцию
вставки данных. При выходе курсора, находящегося в режиме
перетаскивания, за пределы визуального элемента система генерирует
событие dragLeaveEvent. Следует особо отметить, что обработчики событий
не должны уничтожать объекты событий, так как эти объекты контролируются
системой.

Для того, чтобы какой-либо элемент Qt приложения мог принимать данные,
передаваемые посредством Drag and Drop, необходимо создать производный
класс от класса этого элемента, разрешить в этом классе прием Drag and
Drop объектов, вызвав метод setAcceptDrops базового класса QWidget и
заместить методы обработки событий dragEnterEvent, dragMoveEvent,
dragLeaveEvent и DropEvent. Программирование Drag and Drop для Kylix
приложения имеет некоторые отличия. В Kylix-приложении прием объектов
Drag and Drop разрешен для всех компонентов VCL, поэтому вызывать
setAcceptDrops не нужно. Кроме того, поскольку методы компонентов
VisualCLX перекрывают обработчики событий Drag and Drop, подтверждать
Drag and Drop операции необходимо также и в обработчике события
dragMoveEvent. В принципе в Kylix приложении вообще нет необходимости
обрабатывать событие dragEnterEvent, но в приводимом ниже примере такая
обарботка выполняется для большей наглядности.

Демонстрационное приложение позволяет перетаскивать и вставлять
фрагменты текста. Для приема и передачи объектов Drag and Drop
используется компонент Label. Ниже приводится обработчик Qt событий
AppEventHandler.

     procedure TForm1.AppEventHandler;
     var
       QMS : QMimeSourceH;
       S : WideString;
     begin
       Handled:=False;
       if Sender=Label1.Handle then
       if QEvent_isQDropEventEvent(Event) then
       begin
         if QEvent_isQDragEnterEvent(Event) then
         begin
           if QDropEvent_source(QDropEventH(Event))=Label1.Handle then Exit;
           QMS:=QDropEvent_to_QMimeSource(QDropEventH(Event));
           QDropEvent_acceptAction(QDropEventH(Event), QTextDrag_canDecode(QMS));
         end else
         if QEvent_isQDragMoveEvent(Event) then
         begin
           if QDropEvent_source(QDropEventH(Event))=Label1.Handle then Exit;
           QMS:=QDropEvent_to_QMimeSource(QDropEventH(Event));
           QDropEvent_acceptAction(QDropEventH(Event), QTextDrag_canDecode(QMS))
         end else
         begin
           QMS:=QDropEvent_to_QMimeSource(QDropEventH(Event));
           if QTextDrag_canDecode(QMS) then
           QTextDrag_decode(QMS, @S);
           Label1.Caption:=S;
         end;
       end;
     end;

Прежде чем разобрать работу этого метода, отмечу одну деталь: в модуле
Qt содержится ошибка. При первых попытках скомпилировать программу для
работы с Drag and Drop, компиляция проходила без проблем, однако
приложение аварийно завершалось сразу после запуска. Анализ сообщений,
выводимых на консоль, показал, что программа не может разрешить ссылку
на внешний объект с именем QEvent\_isQDropEventEvent. Эта функция
декларируется в файле Qt.pas, однако, судя по сообщениям, выводившимся
во время выполнения программы, разделяемая библиотека libqtintf.so.2 не
экспортирует функцию с таким именем. Очевидно, что в имя функции
вкралась опечатка. Для того, чтобы исправить ошибку я изменил декларацию
внешней функции QEvent\_isQDropEventEvent в файле Qt.pas. В разделе
implementation, в строке, объявляющей экспорт функции, после ключевого
слова name я заменил "QEvent\_isQDropEventEvent" на
"QEvent\_isQDropEvent", после чего программа заработала. Остальные
имена в декларации функции я менять не стал, так что модуль Qt
по-прежнему экспортирует эту функцию как QEvent\_isQDropEventEvent. Если
Вы хотите иметь возможность запускать демонстрационное приложение из
этой статьи, Вы должны сделать тоже самое и перекомпилировать модуль Qt.
Между прочим, эта же ошибка имеет место и в соответствующем модуле
Delphi 6.

Функции QEvent\_isQDragEnterEvent, QEvent\_isQDragMoveEvent и
QEvent\_isQDropEventEvent служат для идентификации событий. Порядок их
вызова неслучаен. Отношения наследования между классами этих трех
событий можно представить так: QDropEvent =\> QDragMoveEvent =\>
QDragEnterEvent. Таким образом функция QEvent\_isQDropEventEvent вернет
значение True для всех трех событий. Действия, связанные собственно с
событием DropEvent, следует выполнять только если первые проверки
вернули False.

Функция QDropEvent\_source вызывает метод source объекта события
QDropEvent - базового объекта событий Drag and Drop. Обратите внимание
на преобразование типа аргумента функции. Такое преобразование
корректно, поскольку объекты QDragEnterEvent и QDragMoveEvent являются
потомками объекта QDropEvent. QDropEvent\_source позволяет определить
источник объекта Drag and Drop. Поскольку в создаваемом приложении
компонент Label является и приемником и источником объектов Drag and
Drop, мы должны проверять, какой Qt объект создал данный объект Drag and
Drop и не выполнять дальнейшую обработку события, если источником
объекта является компонент Label1.

Функция QDropEvent\_to\_QMimeSource преобразует объект типа QDropEvent в
объект типа QMimeSource, являющийся контейнером передаваемых данных.
Функция QDropEvent\_acceptAction позволяет подтвердить операцию Drag and
Drop, или отказаться от нее. Первый аргумент функции - ссылка на объект
QDropEvent, второй аргумент - значение True или False. Для определения
того, следует ли обрабатывать событие, мы используем функцию
QTextDrag\_canDecode. Эта функция возвращает True, если переданный ей
объект QMimeSource содержит данные в текстовом формате и False в
противном случае. Функция QTextDrag\_decode извлекает текстовые данные
из объекта QMimeSource. Обратите внимание, что обработчик не должен
пытаться уничтожить объекты QMimeSource

Для того, чтобы Qt приложение могло стать источником объектов Drag and
Drop, необходимо создать объект-контейнер данных и вызвать один из
методов этого объекта : drag или dragCopy. Объект для перетаскивания
лучше всего создавать в момент начала движения мыши при нажатой левой
кнопке. В нашем приложении эту функцию выполняет обработчик события
OnMouseMove объекта Label1:

     procedure TForm1.Label1MouseMove(Sender: TObject; Shift: TShiftState; X,
       Y: Integer);
     var
       TextDragObject : QTextDragH;
       S : WideString;
       name : PChar;
     begin
       if ssLeft in Shift then
       begin
         S:=Label1.Caption;
         name:='TextDrag';
         TextDragObject:=QTextDrag_create(@S, Label1.Handle, name);
         if QDragObject_drag(TextDragObject) then Label1.Caption:='';
       end;
     end;

Функция QTextDrag\_create создает экземпляр объекта-контейнера
QTextDrag. Первый параметр - указатель на строку текста, которую мы
хотим скопировать. Параметр name может содержать любую строку PChar.
Функция QDragObject\_drag инициирует процесс Drag and Drop. Эта функция
не возвращает управление до тех пор, пока пользователь не отпустит
кнопку мыши. QDragObject\_drag возвращает значение True, если был выбран
режим перемещения данных и False, если был выбран режим копирования.
Выбор режима в системе определяется состоянием клавиши Ctrl. Процедура
QDragObject\_dragCopy выполняет те же действия, но возвращает управление
сразу и не передает программе никаких значений. Хотя функция
QDragObject\_drag возвращает управление обработчику только после того,
как пользователь отпустит левую кнопку мыши, обработчик не должен
пытаться уничтожить объект QDragObject. Время жизни этого объекта
контролируется системой, и попытка уничтожить его вызовет ошибку
сегментации.

Полный исходный текст демонстрационного приложения можно скачать здесь.
При работе с демонстрационным приложением следует учесть, что не все
приложения, написанные для Qt/KDE, поддерживают Drag and Drop. Некоторые
приложения, например KWord, могут быть источниками текстовых объектов
Drag and Drop, но не приемниками. Учтите также, что в настоящее время
Drag and Drop в KDE работает не очень стабильно. Работая с
демонстрационной программой, вы можете столкнуться с тем, что некоторые
другие приложения, использующиеся как источники или приемники объектов
Drag and Drop, будут зависать. Это не связано с Kylix, так как при
использовании "фирменных" примеров из поставки Qt возникают те же
проблемы, по крайней мере на момент написания этой статьи.

Генерация событий Qt в программе

Обычно события Qt генерируются системой в ответ на действия пользователя
или события в самой системе. Однако, иногда бывает желательно вызвать
обработчик события из непосредственно из программы. Для этого необходимо
создать объект соответствующего события и передать его методу Qt
объекта. CLXDisplay API позволяет сделать это при помощи набора функций
QOpenWidget\_XXXEvent, определенных для различных типов событий. В
следующем небольшом примере создаются объекты событий, при помощи
которых в поле ввода визуального компонента Edit1 типа TEdit вводится
текст, а затем эмулируется нажатие клавиши BackSpace (код $1003),
стирающее последний введенный символ.

    var
      KeyEvent : QKeyEventH;
      S : WideString;
     ...
     begin
       ...
       S:='Some little text';
       KeyEvent:=QKeyEvent_create(QEventType_KeyPress, 0, 0, 0, @S, False, 0);
       QOpenWidget_keyPressEvent(QOpenWidgetH(Edit1.Handle), KeyEvent);
       QKeyEvent_destroy(KeyEvent);
       KeyEvent:=QKeyEvent_create(QEventType_KeyPress, $1003, 0, 0, nil, False, 0);
       QOpenWidget_keyPressEvent(QOpenWidgetH(Edit1.Handle), KeyEvent);
       QKeyEvent_destroy(KeyEvent);
       ...

Рассмотренный в этой статье метод обработки событий - не единственный. В
следующей статье будут рассмторены перехватчики событий, а также еще
один механизм взаимодействия между объектами Qt - сигналы и слоты.

Статья и примеры программ © 2001 Андрей Наумович Боровский.

Взято из <https://forum.sources.ru>
