---
Title: Создание веб-сервера
Date: 01.01.2007
Source: www.codersclub.net
ID: 03442
---


Создание веб-сервера
====================

В последнее время возможность управления приложением при
помощи web интерфейса становится все более популярной. Лично я
применил возможность удаленного управления в ряде своих
программ, и это существенно упростило их сопровождение в
условиях большой организации. delphi содержит достаточно
мощные компоненты, позволяющие легко организовывать соединения
по протоколу tcp/ip. Это компоненты tserversocket и
tclientsocket. Для организации web сервера нам потребуется
только tserversocket. Для доступа к нашему серверу применим
порт с номером 5000 (напоминаю, что порты с номерами меньше
1024 могут использоваться только по назначению и есть
опасность, что на Вашей машине будет установлено некоторое
приложение, использующее стандартный порт http 80). При этом
url будет выглядеть как machine:5000/path при доступе из сети
или 127.0.0.1:5000/path при доступе с локального хоста.
Следует сразу поговорить о двух тонкостях, не имеющих прямого
отношения к написанию web сервера

* Два приложения на одном компьютере не могут одновременно
  использовать один и тот-же порт. Поэтому следует выносить
  номер порта в настройки программы и (или) предусматривать
  механизм автоматического выбора одного из альтернативных
  портов на случай, если основной уже занят.

* Следствием из несоблюдения пункта 1 является
  невозможность запуска двух копий одной программы без
  принятия соответствующих мер

* Программа может быть запущена на компьютере, не
  настроенном на работу с сетью. Попытка использования
  компонента tserversocket в этом случае приведет к ошибкам,
  которые могут помешать нормальному запуску программы.

Решением всех этих проблем может послужить следующий совет:
никогда не ставьте свойство `active:= true;` во время дизайна !!
Активируйте компонент tserversocket при старте программы в
конструкции `try ... except;`

Итак, мы поговорили об общих
вопросах. Теперь следует поговорить о протоколе http.

Протокол http - краткая справочная информация.

Обмен по протоколу http производится в т.н. транзакциях, которые
состоят из трех шагов

1. **Установка соединения.**

    Производится по инициативе клиента
    и для этого необходимо знать порт, по которому работает
    сервер.

2. **Запрос клиента.**

    Клиент передает серверу http запрос (содержащий http метод,
    идентификатор ресурса и версию протокола) + дополнительную
    информацию. Пример типового запроса

        get /book/index.htm http/1.0

    Запрос как правило    завершается пустой строкой и
    обязательным crlf. Вот полный  пример запроса ie5 (перехваченный
    кстати при помощи примера 2):

        get /btn7.gif http/1.1
        accept: */*
        referer: http://127.0.0.1:5000/
        accept-language: ru
        accept-encoding: gzip, deflate
        user-agent: mozilla/4.0 (compatible; msie 5.0; windows 98; digext)
        host: 127.0.0.1:5000
        connection: keep-alive

3. **Ответ сервера.**

    Сервер в ответ выдает http ответ +
    дополнительные данные + запрошенную инфомацию (если
    требуется). Ответ сервера всегда состоит из строки с версией
    протокола http, пробела, трехзначного кода статуса, за
    которым через пробел может следовать его расшифровка. После
    этого передается crlf (символов с кодами 0dh, 0ah), затем
    идет необязательная информационная часть в формате
    `параметр=значение` и наконец завершается ответ еще одной
    парой символов crlf. Затем следует запрошенная информация
    (если ее передача возможна и требуется в данном контексте).

    Пример ответа:

        НТТР/1.0 200 ok

4. **Сервер разрывает соединение с клиентом,**

    что служит сигналом к завершению
    обмена. Клиент тоже может прервать обмен на любой стадии,
    разорвав соединение с сервером. Особенно это любит делать
    ie. Он выдает запрос, получает ответ и начинает получать
    данные, а тем временем анализируя полученный ответ выясняет,
    что запрошенный ресурс уже есть в кеше и его не требуется
    загружать. При этом ie разрывает соединение и прерывает
    загрузку.

    Аналогично он ведет себя при нажатии кнопки
    "Стоп". Поэтому при начальном тестировании я бы рекомендовал
    использовать программу net vampire, которая отображает
    подробный протокол обмена с сервером (что и когда передано
    на сервер и что принято в ответ).

**Классы кодов ответа http.**

Как говорилось ранее, код ответа
представляет собой трехзначное число. Коды сгруппированы в
пять категорий, категория определяется первой цифрой

- **1xx - Информационная.** На данный момент зарезервирована
- **2xx - Успешно.** Сообщает об успешном выполнении запроса
- **3xx - Перенаправление.** Указывает клиенту, что для
  выполнения запроса необходимы дополнительные действия
- **4xx - Ошибка клиента.** Сообщает клиенту о том, что запрос
  неполный или содержит синтаксические ошибки. Кроме того,
  ошибки этой категории возникают, если запрошенный ресурс не
  найден или недоступен
- **5xx - Ошибка сервера.** Возникает, если сервер перегружен,
  недоступен или в работе сервера возникли какие либо ошибки

Наибольший интерес представляют собой следующие коды (они
наиболее распространены)

- 200 ОК
- 201 Успешная команда post
- 202 Запрос принят
- 203 Запрос get либо head выполнен
- 204 Запрос выполнен, но нет содержимого
- 300 Ресурс обнаружен в нескольких местах
- 301 Ресурс удален навсегда
- 302 Ресурс временно удален
- 304 Ресурс изменен
- 400 Плохой запрос от клиента
- 401 Неавторизованный запрос
- 402 Необходима оплата за запрос
- 403 Доступ к ресурсу запрещен
- 404 Ресурс не найден
- 405 Метод неприменим для данного ресурса
- 406 Недопустимый тип ресурса
- 410 Ресурс недоступен
- 500 Внутренняя ошибка сервера
- 501 Метод не выполнен
- 502 Перегрузка сервера или неисправный шлюз
- 503 Сервер недоступен или таймаут шлюза
 

**Методы протокола http**

Данная статья не преследует цель описать все подробности
протокола http, но для понимания принципов работы примера
рассмотрим несколько основных методов:

**Метод get**

Метод get является самым часто используемым и предназначен
для получения информации от сервера. В качестве информации
может выступать файл или результаты работы какого либо
процесса, например cgi.
Метод get может дополняться условием
при помощи параметра if-modified-since в запросе - в том
случае результат передается только если ресурс имеет дату
модификации, большую указанной в if-modified-since. Кроме
запроса метод get может применяться для передаче небольших
объемов данных в виде параметров.

**Метод head**

Метод head полностью аналогичен методу get, но в ответ
сервер передает только заголовок (но не передает данные).

**Метод post**

Метод post применяется для передачи серверу данных.

**Метод put**

Метод put предназначен для сохранения данных, переданных
после заголовка запроса, под именем, указанным в запросе.

**Метод delete**

Метод delete используется для удаления ресурсов с указанным
в запросе именем.
 

Итак, мы поговорили о теории (причем это не теория, а
краткий ликбез). Найти более подробное описание достаточно
легко, есть масса сайтов, специализирующихся на подобной
документации. Однако лучше всего почитать стандарты rfc (в
частности, документ rfc2068)

Я не хочу приводить здесь сами исходные тексты - страничка
получится очень большой, поэтому остальная часть стальи в виде
двух хорошо продокументированных проекта лежит в архивах:

**Пример 1.**

Простейший web сервер - база для управления
программой через web. В примере номер 1 мы рассмотрим
создание простейшего web сервера. В ответ на любой запрос он
выдает одну и туже страничку с информацией о клиенте и
формой, демонстрирующей передачу запросов серверу по методу
get. Данный пример может служить прототипом для систем
удаленного управления/администрирования с web интерфейсом.

**Пример 2.**

Обычный web сервер - база для разработки своих
серверов. В этом примере рассмотрен полнофункциональный
сервер. У него определяется директорий, в котором будут
храниться файлы и он может возвращать их по запросам
клиентской программы. Я ради эксперимента разместил на нем
свой сайт по delphi (с которого Вы сейчас читаете эту
статью), и он прекрасно открылся при помощи ie. Единственный
огрех - периодически вылетала ошибка _socket error 10054,_
связанная с тем, что ie брал странички из кеша и рвал
соединение в процессе их передачи.

