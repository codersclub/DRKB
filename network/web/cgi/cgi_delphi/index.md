---
Title: Delphi и CGI
Date: 01.01.2007
---


Delphi и CGI
============

::: {.date}
01.01.2007
:::

В последнее время в связи с растущей популярностью сети Интернет все
чаше становится необходимость разработки приложений, которые бы могли
работать непосредственно в www среде. Т.е. такие, которые бы полностью
бы интегрировались в уже привычные нам веб-странички. По сути дела
работа с таким приложением происходит полностью через любимый браузер
пользователя и ничем не отличается от серфинга по страничкам. Ввод
данных равно как и выдача обработанных результатов происходит через
html-формы веб-страничек. Обработка же данных происходит на веб-сервере.
Таким образом, мы получим самое что ни есть клиент-серверное приложение
в его самом классическом понимании.

Необходимо отметить, что CGI-приложения разрабатываемые в средах
разработки ориентированных на Win32 системы, в том числе и в Дельфи, а
вернее серверная часть такого приложения может работать только под Win32
сервером, например IIS из NT или Personal Web Server из Windows98. Что
касается клиентской части, то здесь никаких проблем совместимости не
должно быть в принципе, т.к. клиентская часть представляет собой
сгенерированный HTML код, который поддерживается любым браузером, не
важно какую платформу использует пользователь, будь то Win32, OS/2, Unix
и др.

Таким образом, программисту пишушему CGI-приложения придется столкнуться
с двумя основными задачами - это разработка веб-интерфейса и разработка
непосредственно математической части приложения.

Что касается веб-интерфейсов, то здесь желательно знать хотя бы основы
языка HTML. Здесь мы не будем уделять этому особое внимание, хотя знание
HTML для программиста CGI-приложений очень желательно. Сейчас же для нас
будет вполне достаточным знание таких основопологающих тэгов как
\<HTML\>,\<BODY\> и конструкции \<FORM\>.

Ну а теперь будем разбираться непосредственно с телом CGI-приложения.
Во-первых, что такое CGI-приложение разрабатываемое в Win32 среде
разработки? Это приложение типа Win32 CONSOLE, т.е. консольное
приложение Win32. Только вот для такого приложения в отличии от
классической Win32 консоли стандартным устройством ввода является либо
поля ввода HTML формы либо строка адреса браузера, а в качестве
стандартного устройства вывода используется окно браузера. Активизация
приложения происходит непосредственно из какой-либо HTML странички,
например так \<A HREF="http://myhost/myapp.exe"\>My Application\</A\>
Как мы уже выяснили такое CGI-приложение будет представлять собой
исполняемую Win32 программу (exe), таким веб-приложениям принято давать
расширение CGI, хотя это и непринципиально.

Для начала рассмотрим пример самой простой CGI-программки выдающей в
окно пользовательского браузера текст "HELLO WORLD".

    program MyApp
    {$APPTYPE CONSOLE}        // тип приложения Win32 консоль
    {$E cgi}                // Расширение приложения cgi
    begin
      WriteLn('Content-Type: text/html');
      WriteLn;
      WriteLn;
      WriteLn('<HTML>');
      WriteLn('<HEAD>');
      WriteLn('<TITLE>Простейшее CGI приложение</TITLE>');
      WriteLn('<META http-equiv="Content-Type" content="text/html;' +
                                    ' charset=windows-1251">');
      WriteLn('</HEAD>');
      WriteLn('<BODY>');
      WrОтiteLn('<H1>HELLO WORLD</H1>');
      WriteLn('</BODY>');
      WriteLn('</HTML>');
    end.
     

Откомпиллируйте этот исходный код в среде Дельфи, поместите
скомпонованный исполняемый код в ваш CGI-BIN каталог ( в каталог, где
разрешено исполнение скриптов), напишите небольшую веб страничку для
активизации нашего CGI-приложения, например, такую:

\<HTML\>

\<HEAD\>

\<TITLE\>Форма для активизации CGI-приложения\</TITLE\>

\</HEAD\>

\<BODY\>

\<A HREF="http://localhost/cgi-bin/myapp.cgi"\>

Нажми сюда для запуска приложения\</A\>

\</BODY\>

\</HTML\>

Теперь откройте нашу веб-страничку и перейдите по ссылке "Нажми сюда
для запуска приложения". Если вы все сделали правильно, то на экране в
окне вашего любимого браузера появиться текст "HELLO WORLD".

Как видите все достаточно просто! Однако, для полноценной работы
приложения, оно должно уметь не только выводить некие данные, но
получать данные от пользователя, т.е. обеспечивать ввод информации. Ввод
данных в случае CGI-приложения, как мы уже говорили, будет
осуществляться по средствам интерфейса организованного веб-формой. Такая
форма может передавать данные двумя способами, в зависимости от значения
атрибута "METHOD".

В случае \<FORM METHOD="GET" ...\>... данные передаются через строку
адреса браузера и записываются в переменную системного окружения
QUERY\_STRING, а размер строки данных в переменную CONTENT\_LENGTH.

В случае \<FORM METHOD="POST" ...\>... передаваемые данные в строке
адреса не отображаются, передаются через стандартный поток ввода
консольной программы.

Таким образом задача получения данных CGI-приложением сводится к чтению
определенной переменной окружения. Надо отметить, что передаваемые
веб-формой данные имеют следующий формат:
\<имя\_атрибута1\>=\<значение\_атрибута1\>&\<имя\_атрибута2\>=\<значение\_атрибута2\>...

Задача программиста сводится к извлечению значений нужных атрибутов из
полученной от браузера строки и преобразования этих значений из вида
URLencoded в обычные текстовые данные. Суть URLencoded формата
заключается в том, что некоторые символы, содержащиеся в значении поля,
заменяются на % и следующим за ним шестнадцатиричным кодом символа, а
пробел заменяется на +.

А сейчас давайте рассмотрим пример CGI приложения, которое бы
производило подобие некоторой идентификации пользователя системы.

\<!\-- HTML форма ввода пароля \--\>

\<HTML\>

\<HEAD\>

\<TITLE\>Авторизация доступа\</TITLE\>

\</HEAD\>

\<BODY\>

\<FORM method="POST"
action="http://localhost/cgi-bin/chkpaswd.cgi"\>

Введите пароль:

\<input type="text" name="paswd" size=20\>

\<input type="submit" value="Найти"\>

\<input type="reset" value="Очистить"\>

\</FORM\>

\</BODY\>

\</HTML\>

Далее идет пример непосредственно CGI приложения. Следует отметить, что
приведенный в этом примере способ получения данных от веб формы
(непосредственное чтение устройства стандартного ввода STD\_INPUT)
является наиболее наглядным, но не самым удобным, в Дельфи
предусмотренны более удобные механизмы, которых мы каснемся позже.

    {Файл проекта CGIApp2}
    program CGIApp2;
     
    {$APPTYPE CONSOLE}
     
    uses 
      MainUn in 'MAinUn.pas';
     
    {$E cgi}
     
    begin
      Main;
    end.
     
    program MainUn;
    interface
    uses
      SysUtils, Windows, Classes;
     
    implementation
     
    // Функция перевода шестнадцетиричного символа в число
    function HexToInt(CH : char): integer;
    begin
      Result:=0;
      case CH of
        '0'..'9': Result:=Ord(CH)-Ord('0');
        'A'..'F': Result:=Ord(CH)-Ord('A')+10;
        'a'..'f': Result:=Ord(CH)-Ord('a')+10;
      end;
    end;
     
    // Преобразует символы, записанные в виде URLencoded
    function Decode(Value: string): string;
    var
      i, L: integer;
    begin
      Result:='';
      L:=0;
      for i := 1 to Length(Value) do
      begin
        if(Value[i] <> '%') and (Value[i] <> '+') and (L<1) then
        begin
          Result := Result + Value[i];
        end
        else
        begin
          if(Value[i] = '+') then
            Result := Result + ' '
          else if(Value[i] = '%') then
          begin
            L := 2;
            if(i < Length(Value) - 1) then
            begin
              Result := Result + Chr(HexToInt(Value[i+1]) * 16 + 
                                            HexToInt(Value[i+2]));
            end;
          end
          else
            Dec(L);
        end;
      end;
    end;
     
    // Фнкция возвращает значение атрибута заданного 
    //в качестве параметра функции из строки данных 
    //считанной из устройства стандартого ввода.
     
    function ParamByName(Name: string): string;
    var
      SS, ST : string;
      K : integer;
    begin
     
      Result := '';
      SS := InParams;
     
      while Length(SS) <> 0 do
       begin
        K := Pos('&',SS);
        if (K <> 0) then
        begin
          ST := Copy(SS,1,K-1);
          SS := Copy(SS,K+1,10000);
        end
         else
         begin
          ST :=SS;
          SS:='';
        end;
        K := Pos('=',ST);
        if(K <> 0) then
        begin
          if(Name = Copy(ST,1,K-1)) then
          begin
            Result := Decode(Copy(ST,K+1,6000));
          end;
        end;
      end;
    end;
     
    procedure Main;
    var
      STR : string;
      StdIn, Size, Actual : cardinal; 
      InParams : string;
    const
      UserPassword : String = 'MyPass';
    begin
      StdIn := GetStdHandle(STD_INPUT_HANDLE);
      Size := SetFilePointer(StdIn, 0, nil, FILE_END);
      SetFilePointer(StdIn, 0, nil, FILE_BEGIN);
      SetLength(STR,Size+1);
      if (Size <= 0) then
        Exit;
      // Читаем данные из стандартного устройства ввода
      ReadFile(StdIn, STR[1], Size, Actual, nil); 
      STR[Size+1] := #0;
      InParams := PChar(@STR[1]);
     
      APasswd := ParamByName('paswd');
     
      WriteLn('Content-Type: text/html');
      WriteLn;
      WriteLn;
      WriteLn('<HTML>');
      WriteLn('<HEAD>');
      WriteLn('<TITLE>Идентификация пользователя</TITLE>');
      WriteLn('<META http-equiv="Content-Type" content="text/html;'+
                                            ' charset=windows-1251">');
      WriteLn('</HEAD>');
      WriteLn('<BODY>');
      if APasswd = UserPassword then
        WriteLn('<H1>Успешная идентификация!</H1>')
      else
        WriteLn('<H1>Пароль введен неверно!</H1>')
      WriteLn('</BODY>');
      WriteLn('</HTML>');
     
    end;

Ну, вот пока что все. Но это совсем не значит, что мы полностью охватили
всё, что касается разработки CGI приложений на Дельфи. В самое ближайшее
время я обязательно продолжу это повествование, ведь впереди еще столько
интересной и полезной информации. Так что, до скорого!        

Взято из <https://forum.sources.ru>
