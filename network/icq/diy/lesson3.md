---
Title: Урок №3
Author: Alexander Vaga, alexander_vaga@hotmail.com
Date: 22.05.2002
Source: <https://delphiworld.narod.ru>
---


Урок №3
==============================

статья: [ICQ2000 - сделай сам](./)

<table>
<tr>
<td style="border:0;width:50%;">
![](chatting.jpg)
</td>
<td style="border:0;">
_Двое влюбленных лежат в постели, утомленные бурным сексом.  
- Милый, а ты помнишь, когда мы с тобой познакомились?  
- Погоди... ща отдышусь и пойду хистори в аське посмотрю._
</td>
</tr>
</table>



## Запрос информации о клиенте, Поиск клиентов по различным критериям и др.

Итак...
Передавать и принимать сообщения уже умеем. На очереди -
получение информации о клиентах, которые находятся в списке контактов; а
также поиск новых клиентов по различным критериям. Такие запросы к
серверу посылаются с помощью все тех же SNAC(15,2). Вспомните, как
производится запрос оффлайновых сообщений.

Точно также SNAC(15,2) с типом запроса равным D007 применяется:

- при всех операциях с Инфо клиентов ( и получение, и обновление своего);
- при поиске клиентов по имени, по UINу, по E-mailу;
- при изменении пароля;
- при удалении UINа из реестра ICQ;
- при многих других операциях.

Каждая из перечисленных операций определяется подтипом запроса. Приведу
обобщенную таблицу SNAC(15,2) для некоторых запросов:

<table>
<tr>
  <th colspan="2">FLAP</th>
</tr>
<tr>
  <td width="25%">Command Start</td>
  <td>2A</td>
</tr>
<tr>
  <td>Channel ID</td>
  <td>02</td>
</tr>
<tr>
  <td>Sequence Number</td>
  <td>XX XX</td>
</tr>
<tr>
  <td>Data Field Length</td>
  <td>XX XX</td>
</tr>
<tr>
  <td colspan="2">
    <table>
    <tr>
      <th colspan="2">SNAC (15, 02)</th>
    </tr>
    <tr>
      <td width="25%">Family ID</td>
      <td><b>00 15</b></td>
    </tr>
    <tr>
      <td>SubType ID</td>
      <td><b>00 02</b></td>
    </tr>
    <tr>
      <td>Flags[0]</td>
      <td>00</td>
    </tr>
    <tr>
      <td>Flags[1]</td>
      <td>00</td>
    </tr>
    <tr>
      <td>Request ID</td>
      <td>00 XX 00 02 (по ним можно опознать ответ) </td>
    </tr>
    <tr>
      <td colspan="2">
        <table>
        <tr>
          <th colspan="3">TLV (1)</th>
        </tr>
        <tr>
          <td width="25%"><b>T</b>ype</td>
          <td colspan="2"><b>00 01</b></td>
        </tr>
        <tr>
          <td><b>L</b>ength</td>
          <td colspan="2">XX XX </td>
        </tr>
        <tr>
          <td rowspan="6"><b>V</b>alue</td>
          <td><b>L</b>ength-2<br></td>
          <td>(и что <i>оно</i> тут делает ?)</td>
        </tr>
        <tr>
          <td>XX XX XX XX</td>
          <td>наш UIN</td>
        </tr>
        <tr>
          <td><b>D0 07</b></td>
          <td><b>тип запроса</b></td>
        </tr>
        <tr>
          <td>XX 00</td>
          <td>cookie <br>(по нему можно/нужно<br>опознавать ответ)</td>
        </tr>
        <tr>
          <td><b>B2 04</b></td>
          <td><b>подтип запроса<br></b>(<b>B204</b> - запрос инфо клиента) </td>
        </tr>
        <tr>
          <td colspan="2">
            Это переменная часть зпроса.<br>
            Она определяется <b>подтипом</b> запроса.<br><br>
            Например:<br><br>
            При запросе инфо клиента (<b>B2 04</b>) или при поиске клиента по UINу (<b>1F05</b>)
            здесь следует разместить запрашиваемый UIN.<br><br>
            При поиске клиента по E-mail (<b>2905</b>)
            здесь будет помещена строка с искомым адресом.<br><br>
            При поиске по NickName, FirstName, LastName
            (<b>1505</b>) сюда помещаются соответственно три стоки.<br><br>
            При смене пароля (<b>2E04</b>) здесь будет лишь строка с паролем, <br>
            а <i>наш</i> UIN сервер и так знает.
          </td>
        </tr>
        </table>
      </td>
    </tr>
    </table>
  </td>
</tr>
</table>


Теперь к Delphi-проекту добавлены еще два модуля:
[UInfo](uinfo_pas/)
и [SUser](suser_pas/) (User Info & Search User).

Очередные исходники 3-его урока здесь: [icq_lesson3.zip](icq_lesson3.zip).


Т.к. все рассмотренные выше
запросы практически однотипные, то приведу комментарии только к одному
из них. Это будет поиск по NickName, FirstName, LastName:

    unit SUser; 
     
     
    procedure TSearchUser.META_Search_User(NN,FN,LN : string);
    var p : PPack;
        // промежуточный массив.
        // в нем накапливаются данные TLV(1)
        b : TByteArray;
        i : integer;
    begin
         if (NN='')and(FN='')and(LN='') then exit;
         EndOfSearch := false;
     
         // word(b[0]) - тут будет ненужная длина
         // (но ее надо потом корректно заполнить)
         // а пока переходим к 3-у елементу
         i:=2;
     
         // вписываем UIN (только СВОЙ - укажем явно,что из модуля Main.pas)
         PLONG(@(b[i]))^ := main.UIN;    inc(i,4);
         // ТИП запроса
         PWORD(@(b[i]))^ := swap($D007);   inc(i,2);
         // придумаем себе COOKIE
         // (можно и по-проще, но в настоящей аське
         // COOKIE имеет такой вид XX00)
         Cookie := random($FF) shl 8;
         PWORD(@(b[i]))^ := swap(Cookie); inc(i,2);
         // ПОДТИП запроса
         PWORD(@(b[i]))^ := swap($1505);   inc(i,2);
     
         // добавляем три текстовые строки (First, Last, Nick)
         // у AOL новый тип строк наверное :)
         // впереди - длина строки, а в конце #0
         // (что-то одно из них убрали бы)
     
         // длина строки
         PWORD(@(b[i]))^ := length(FN)+1;  inc(i,2);
         // сама строка FirstName
         MOVE(FN[1],b[i],length(FN));     inc(i,Length(FN));
         // завершающий #0
         PBYTE(@(b[i]))^ := 0;             inc(i,1);
     
         // LastName
         PWORD(@(b[i]))^ := length(LN)+1;  inc(i,2);
         MOVE(LN[1],b[i],length(LN));     inc(i,Length(LN));
         PBYTE(@(b[i]))^ := 0;             inc(i,1);
     
         // NickName
         PWORD(@(b[i]))^ := length(NN)+1;  inc(i,2);
         MOVE(NN[1],b[i],length(NN));     inc(i,Length(NN));
         PBYTE(@(b[i]))^ := 0;             inc(i,1);
     
         // дозаполним "ненужную" длину в начале массива
         PWORD(@(b[0]))^ := i-2;
         // создаем FLAP-пакет
         P:=CreatePacket(2,SEQ);
         // добавляем SNAC(15,2)
         SNACAppend(p,$15,$2);
         // добавляем TLV(1) с данными из промежуточного массива
         TLVAppend(p,1,i,@b);
         // шлем запрос
         Form1.PacketSend(p);
         // пишем в Memo
         M(Form1.Memo,'> Search Detail: Nick:'+NN+
                                   '   First:'+FN+
                                    '   Last:'+LN+'   '+
                                     'Cookie:$'+inttohex(Cookie,4));
    end;

Запросы других подтипов передаются аналогично. С небольшими вариациями.
Оновременно можем передавать на сервер много запросов. Сервер
разберется. Ведь в каждом нашем запросе есть уникальное(ый) Cookie (а
также и RequestID в SNAC-заголовке). Сервер пометит свои пакеты-ответы
этими же опознавательными знаками.

Я лично делаю проверку(сверку) только по Cookie. Выдавая запрос,
запоминаю Cookie. А когда приходит ответ от сервера, то
процедура-обработчик SNAC\_15\_3 просто использует WinAPI функцию
PostMessage для передачи ответа окну, которое выдало запрос. В
параметрах PostMessage указан Cookie из ответа сервера. Какое окно его
опознает - значит тому окну и предназначен ответ.

Работа процедуры-обработчика SNAC\_15\_3 уже ранее рассматривалась.
Сейчас она просто дополнена новыми блоками, обрабатывающими новые ответы
сервера. Следует упомянуть, что на один (единственный) наш запрос сервер
присылает сразу целый массив из SNAC-ответов. Это типичная ситуация.

Например: запрашиваем Инфо о клиенте SNAC(15,2) [подтип запроса B204].

В ответ получим сразу восемь SNAC-ответов.

Вот их краткие названия-описания:

- main-home-info
- homepage-more-info
- more-email-info
- additional-info
- work-info
- about
- personal-interests
- past-background

Все полученные данные теперь сохраняются в файле .dat
