Как реализовать обработку информации одновременно несколькими потоками?
=======================================================================

::: {.date}
01.01.2007
:::

Автор: Садыков Алексей Николаевич

Запускайте Delphi. Итак, наша программа будет представлять из себя форму
с двумя edit\'ами и кнопкой. Добавьте их на форму.

При нажатии на кнопку будут осуществляться некоторые долгие вычисления.
Если бы мы не использовали потоки, то, пока эти вычисления не
закончатся, делать мы ничего бы не смогли. Надо было бы ждать. Но, так
как потоки у нас будут, то во время долгих вычислений можно будет
что-нибудь вводить во второй edit (он, собственно, только для этого и
существует). В первый же edit наш поток будет выводить некоторые
промежуточные результаты своей работы.

Добавьте в программу еще один модуль (меню File, New, Unit).

Внесите в окно кода нового модуля следующий код:

    unit Unit2;
     
    interface
     
    uses
      Classes;
     
    type
      TMyThread = class(TThread) //Новый класс
      private
        answer: Integer;
      protected
        procedure ShowResult;
        procedure Execute; override;
      end;
     
    implementation
     
    uses
      SysUtils, Unit1;
     
    //Процедура для вывода информации из потока
    procedure TMyThread.ShowResult;
    begin
      Form1.Edit1.Text := IntToStr(answer);
    end;
     
    //Длинная процедура
    procedure TMyThread.Execute;
    var
      i: Integer;
    begin
      for i := 1 to 10000 do
      begin
        answer := answer + 1;
        Synchronize(ShowResult);
      end;
    end;
     
    end.

Немного комментария по коду. В нашем модуле мы вводим новый класс
TMyThread как «потомок» TThread. В экземпляре нашего класса и будет
выполнятся отдельный поток программы. В классе есть процедура ShowResult
для вывода информации из работающего потока в основной поток (форму)
нашей программы. Кроме того, в классе есть наша версия метода Execute из
родительского класса TThread. Обратите внимание, что в нашей реализации
Execute мы пишем

Synchronize(ShowResult);

Тем самым наш поток что-то отправляет в основной поток программы (в
данном случае, значение переменной answer). Делаем мы это посредством
вызова Synchronize, в котором в качестве параметра указываем имя нужной
процедуры.

Теперь переходим к нашему основному модулю Unit1. Во-первых, добавьте в
секцию uses ссылку на Unit2:

    uses
      Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, 
      Forms, Dialogs, StdCtrls, Unit2;

Во-вторых, напишите обработчик для нажатия кнопки:

    procedure TForm1.Button1Click(Sender: TObject);
    var
      MyThread: TMyThread;
    begin
      MyThread := TMyThread.Create(False);
    end;

Тут мы создаем второй поток для нашего приложения. Параметр False
означает, что метод Execute для нашего потока вызовется немедленно.

Запускайте программу. Нажимайте на кнопку. В первом edit\'е замелькают
промежуточные результаты работы второго потока. Во время его работы вы
можете вводить информацию во второй edit --- т.е. работа одного потока
не мешает работе другого.

Взято с <https://delphiworld.narod.ru>
