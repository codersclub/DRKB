<h1>Протокол SOCKS 5</h1>
<div class="date">01.01.2007</div>

<p>Протокол SOCKS 5</p>
<p>Статус данного документа</p>
<p>   Этот документ описывает протокол связи по стандартам Интернет, и открыт</p>
<p>   для обсуждения и предложений. Пожалуйста обращайтесь к текущей редакции</p>
<p>   "Internet Official Protocol Standards" (STD 1) чтобы справится о стадии</p>
<p>   стандартизации и статусе этого протокола. Распространение этого документа</p>
<p>   не ограничивается.</p>
<p>Благодарности</p>
<p>   Этот документ описывает протокол, который является развитием предыдущей</p>
<p>   версии протокола 4 [1]. Этот новый протокол основывается на бурных</p>
<p>   дискуссиях и прототипах реализаций. Основной вклад внесли:</p>
<p>   Marcus Leech: Bell-Northern Research, David Koblas: Independent Consultant,</p>
<p>   Ying-Da Lee: NEC Systems Laboratory, LaMont Jones: Hewlett-Packard Company,</p>
<p>   Ron Kuris: Unify Corporation, Matt Ganis: International Business Machines.</p>
<p>1.  Введение</p>
<p>   Использование сетевых файрволов и систем, эффективно скрывающих</p>
<p>   организацию внутренней сетевой структуры от внешней сети, такой</p>
<p>   как Интернет, становится все более популярным. Эти файрволы обычно</p>
<p>   работают как гэйтэвэи прикладного уровня между сетями, предлагая</p>
<p>   обычно администрируемый TELNET, FTP, и SMTP доступ. С появлением</p>
<p>   более сложных протоколов прикладного уровня предназначенных для</p>
<p>   облегчения глобального информационного взаимодействия, появилась</p>
<p>   потребность в обеспечении общей основы для прозрачной и безопасной</p>
<p>   работы через файрволл для этих протоколов.</p>
<p>Leech, et al                Standards Track                 [Страница 1]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>   Существует также необходимость в строгой аутентификации при работе через</p>
<p>   файрволл, в некоторой степени похожей на используемые сейчас методы. Это</p>
<p>   требование обусловлено тем, что отношения типа клиент-сервер появляются</p>
<p>   между сетями различных организаций, и эти отношения должны быть</p>
<p>   управляемыми и, зачастую, строго аутентифицированны.</p>
<p>   Описываемый здесь протокол разработан чтобы обеспечить основу для</p>
<p>   удобного и безопасного использования сервиса сетевых файрволов для</p>
<p>   приложений типа клиент-сервер работающих по протоколам TCP и UDP.</p>
<p>   Протокол представляет собой "уровень-прокладку" между прикладным</p>
<p>   уровнем и транспортным уровнем, и, как таковой, не обеспечивает</p>
<p>   сервиса гэйтэвэев сетевого уровня, такого как пересылка пакетов ICMP.</p>
<p>2.  Текущее положение дел</p>
<p>   Существующий сейчас протокол, SOCKS v4, предназначен для работы через</p>
<p>   файрволл без аутентификации для приложений типа клиент-сервер работающих</p>
<p>   по протоколу TCP, таких как TELNET, FTP и таких популярных протоколов</p>
<p>   обмена информацией, как HTTP, WAIS и GOPHER.</p>
<p>   Новый протокол расширяет модель SOCKS v4 добавляя к ней поддержку UDP,</p>
<p>   обеспечение универсальных схем строгой аутентификации и расширяет</p>
<p>   методы адресации, добавляя поддержку доменных имен и адресов IP v6.</p>
<p>   Реализация протокола SOCKS обычно влечет за собой перекомпиляцию или</p>
<p>   пересборку клиентских программ, работающих по протоколу TCP, для</p>
<p>   использования оответствующх функций SOCKS-библиотеки.</p>
<p>Замечание:</p>
<p>   Если не оговорено обратное, десятичные числа в диаграммах формата</p>
<p>   пакетов обозначают длинну соответствующего поля в октетах (8-битных</p>
<p>   элементах). Если октет должен иметь определенное значение, используется</p>
<p>   обозначение X'hh' для определения значения октета в данном поле.</p>
<p>   Если используется слово 'Variable', это означает, что соответствующее</p>
<p>   поле имеет переменную длинну, определяемую либо связанным (одно- или</p>
<p>   двух-октетным) полем длинны, либо типом данных данного поля.</p>
<p>3.  Процедура для клиентов работающих по TCP</p>
<p>   Когда работающий по TCP клиент хочет соединиться с объектом, доступным</p>
<p>   только через файрволл, он должен открыть TCP-соединение c</p>
<p>   соответствующим SOCKS-портом SOCKS-сервера. Сервис SOCKS обычно</p>
<p>   находится на TCP-порту 1080. Если соединение прошло успешно, клиент</p>
<p>   начинает переговоры о методе аутентификации, который будет</p>
<p>Leech, et al                Standards Track                 [Страница 2]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>   использоваваться, проходит аутентификацию по выбранному методу и</p>
<p>   посылает свой запрос. SOCKS-сервер обрабатывает запрос и либо</p>
<p>   пытается установить соответствующее соединение, либо отказывает в нем.</p>
<p>   Клиент соединяется с сервером и посылает сообщение с номером версии</p>
<p>   и выбором соответствующего метода аутентификации:</p>
<p>                   +----+----------+----------+</p>
<p>                   |VER | NMETHODS | METHODS  |</p>
<p>                   +----+----------+----------+</p>
<p>                   | 1  |    1     | 1 to 255 |</p>
<p>                   +----+----------+----------+</p>
<p>   Значение поля VER равно X'05' для данной версии протокола. Поле</p>
<p>   NMETHODS содержит число октетов в идентификаторах методов авторизации</p>
<p>   в поле METHODS.</p>
<p>   Серевер выбирает один из предложенных методов, перечисленных в METHODS,</p>
<p>   и послылает ответ о выбранном методе:</p>
<p>                         +----+--------+</p>
<p>                         |VER | METHOD |</p>
<p>                         +----+--------+</p>
<p>                         | 1  |   1    |</p>
<p>                         +----+--------+</p>
<p>   Если выбранный метод в METHOD равен X'FF', то ни один из предложенных</p>
<p>   клиентом методов не применим и клиент должен закрыть соединение.</p>
<p>   Эти значения определены для поля METHOD:</p>
<p>          o  X'00' аутентификация не требуется</p>
<p>          o  X'01' GSSAPI</p>
<p>          o  X'02' USERNAME/PASSWORD (см. RFC1929)</p>
<p>          o  X'03' до X'7F' зарезервировано IANA</p>
<p>          o  X'80' до X'FE' преднозначено для частных методов</p>
<p>          o  X'FF' нет применимых методов</p>
<p>   Затем клиент и сервер начинают аутентификацию согласно выбранному методу.</p>
<p>Leech, et al                Standards Track                 [Страница 3]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>   Описание методов аутентификации находится в отдельных документах.</p>
<p>   Разработчики новых методов аутентификации применимых для этого протокола</p>
<p>   должны обращаться в IANA для получения номера метода. Документ с</p>
<p>   выделеными номерами должен дополнить текущий список номеров и</p>
<p>   соответствущих им методов аутентификации.</p>
<p>   Совместимые реализации должны поддерживать GSSAPI и могут поддерживать</p>
<p>   аутентификацию USERNAME/PASSWORD.</p>
<p>4.  Запросы</p>
<p>   После того как аутентификация выполнена, клиент посылает детали запроса.</p>
<p>   Если выбранный метод аутентификации требует особое формирование пакетов</p>
<p>   с целью проверки целостности и/или конфедициальности, запросы должны</p>
<p>   инкапсулироваться в пакет, формат которого определяется выбранным</p>
<p>   методом.</p>
<p>   SOCKS-запрос формируется следующим образом:</p>
<p>        +----+-----+-------+------+----------+----------+</p>
<p>        |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</p>
<p>        +----+-----+-------+------+----------+----------+</p>
<p>        | 1  |  1  | X'00' |  1   | Variable |    2     |</p>
<p>        +----+-----+-------+------+----------+----------+</p>
<p>     Где:</p>
<p>          o  VER    версия протокола: X'05'</p>
<p>          o  CMD</p>
<p>             o  CONNECT X'01'</p>
<p>             o  BIND X'02'</p>
<p>             o  UDP ASSOCIATE X'03'</p>
<p>          o  RSV    зарезервировано</p>
<p>          o  ATYP   тип адреса, следующего вида:</p>
<p>             o  IP v4 адрес: X'01'</p>
<p>             o  имя домена:  X'03'</p>
<p>             o  IP v6 адрес: X'04'</p>
<p>          o  DST.ADDR требуемый адрес</p>
<p>          o  DST.PORT требуемый порт (в сетевом порядке октетов)</p>
<p>   SOCKS-сервер обрабатывает запрос на основании исходного и целевого</p>
<p>   адресов и посылает одно или несколько сообщений в ответ, в соответствии</p>
<p>   с типом запроса.</p>
<p>Leech, et al                Standards Track                 [Страница 4]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>5.  Адресация</p>
<p>   Тип адреса содержащегося в адресном поле (DST.ADDR, BND.ADDR),</p>
<p>   определяется содержимым поля ATYP:</p>
<p>          o  X'01'</p>
<p>   адрес является адресом IP v4, длинна адреса 4 октета</p>
<p>          o  X'03'</p>
<p>   поле адреса содержит имя домена. Первый октет адресного поля содержит</p>
<p>   число октетов в последующем за ним имени, завершающий NUL-октет в конце</p>
<p>   строки не применяется.</p>
<p>          o  X'04'</p>
<p>   адрес является адресом IP v6, длинна адреса 16 октет</p>
<p>6.  Ответы</p>
<p>   SOCKS-запрос посылается клиентом как только он установил соединение с</p>
<p>   SOCKS-сервером и выполнил аутентификацию. Сервер обрабатывает запрос и</p>
<p>   посылает ответ в следующей форме:</p>
<p>        +----+-----+-------+------+----------+----------+</p>
<p>        |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</p>
<p>        +----+-----+-------+------+----------+----------+</p>
<p>        | 1  |  1  | X'00' |  1   | Variable |    2     |</p>
<p>        +----+-----+-------+------+----------+----------+</p>
<p>     Где:</p>
<p>          o  VER    версия протокола: X'05'</p>
<p>          o  REP    код ответа:</p>
<p>             o  X'00' успешный</p>
<p>             o  X'01' ошибка SOCKS-сервера</p>
<p>             o  X'02' соединение запрещено набором правил</p>
<p>             o  X'03' сеть недоступна</p>
<p>             o  X'04' хост недоступен</p>
<p>             o  X'05' отказ в соединении</p>
<p>             o  X'06' истечение TTL</p>
<p>             o  X'07' команда не поддерживается</p>
<p>             o  X'08' тип адреса не поддерживается</p>
<p>             o  X'09' до X'FF' не определены</p>
<p>          o  RSV    зарезервирован</p>
<p>          o  ATYP   тип последующего адреса</p>
<p>Leech, et al                Standards Track                 [Страница 5]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>             o  IP v4 адрес: X'01'</p>
<p>             o  имя домена:  X'03'</p>
<p>             o  IP v6 адрес: X'04'</p>
<p>          o  BND.ADDR       выданный сервером адрес</p>
<p>          o  BND.PORT       выданный сервером порт (в сетевом порядке октетов)</p>
<p>   Значения зарезервированных (RSV) полей должны быть установлены в X'00'.</p>
<p>   Если выбранный метод аутентификации требует особое формирование пакетов</p>
<p>   с целью проверки целостности и/или конфедициальности, запросы должны</p>
<p>   инкапсулироваться в пакет, формат которого определяется выбранным</p>
<p>   методом.</p>
<p>CONNECT</p>
<p>   В ответ на CONNECT, BND.PORT содержит номер порта, который сервер</p>
<p>   назначает для соединения с указанным хостом, а BND.ADDR содержит</p>
<p>   связанный IP-адрес. Выданный BND.ADDR зачастую отличается от</p>
<p>   IP-адреса, который клиент использует для доступа к SOCKS-северу,</p>
<p>   так как такие сервера часто имеют несколько IP-адресов. Ожидается,</p>
<p>   что сервер будет использовать DST.ADDR и DST.PORT и адрес клиента</p>
<p>   при обработке запроса CONNECT.</p>
<p>BIND</p>
<p>   Запрос BIND используется в протоколах, которые требуют чтобы клиент</p>
<p>   принимал соединение со стороны сервера. Хорошим примером этого</p>
<p>   является FTP, который использует основное соединение клиент-к-серверу</p>
<p>   для комманд и сообщений, но может использовать соединение</p>
<p>   сервер-к-клиенту для передачи данных по запросу (например LS, GET, PUT).</p>
<p>   Ожидается, что клиентская сторона прикладного протокола будет</p>
<p>   использовать запрос BIND только для установки вторичного соединения,</p>
<p>   после первичного соединения, установленного с использованием CONNECT.</p>
<p>   Ожидается, что сервер будет использовать DST.ADDR и DST.PORT</p>
<p>   при обработке запроса BIND.</p>
<p>   SOCKS-сервер посылает два ответа клиенту в течении операции BIND.</p>
<p>   Первый послыается после того, как сервер создает и привязывает</p>
<p>   новый сокет. Поле BND.PORT содержит номер порта, который SOCKS-сервер</p>
<p>   выделил для входящего соединения. Поле BND.ADDR содержит связанный</p>
<p>   IP-адрес. Клиент может использовать эту информацию для уведомления</p>
<p>   (через первичное соединение) приложения-сервера об адресе для</p>
<p>   взаимодействия. Второе уведомление происходит после ожидаемого</p>
<p>   входящего соединения или неудачной попытке входящего соединения.</p>
<p>Leech, et al                Standards Track                 [Страница 6]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>   При втором ответе поля BND.PORT и BND.ADDR содержат адрес и номер</p>
<p>   порта присоединившегося хоста.</p>
<p>UDP ASSOCIATE</p>
<p>   Запрос UDP ASSOCIATE используется для установления соединения</p>
<p>   посылающим UDP-сообщения процессом. Поля DST.ADDR и DST.PORT содержат</p>
<p>   адрес и порт, на который клиент собирается слать UDP-датаграммы</p>
<p>   после установки соединения. Сервер может использовать эту информацию</p>
<p>   в целях ограничения доступа. Если клиент не располагает информацией</p>
<p>   об адресе на момент запроса UDP ASSOCIATE, то клиент должен заполнить</p>
<p>   нулями номер порта и адреса.</p>
<p>   UDP-связь обрывается, когда обрывается TCP-соединение выполнившее</p>
<p>   запрос UDP ASSOCIATE.</p>
<p>   В ответе на запрос UDP ASSOCIATE, поля BND.PORT и BND.ADDR определяют</p>
<p>   порт и адрес, куда клиент должен слать UDP-датаграмы для пересылки.</p>
<p>Обработка ответов</p>
<p>   Когда приходит ответ с сообщением о неудаче (значение REP не равно</p>
<p>   X'00'), то SOCKS сервер должен оборвать TCP-соединение вскоре после</p>
<p>   посылки ответа. Это должно произойти не более чем спустя 10 секунд</p>
<p>   после определения причин вызвавших неудачу.</p>
<p>   При получении ответа с сообщением об удаче (значение REP равно X'00'),</p>
<p>   если запросом был BIND или CONNECT, то клиент может начинать передавать</p>
<p>   данные. Если выбранная схема аутентификации требует особое формирование</p>
<p>   пакетов с целью проверки целостности и/или конфедициальности, данные</p>
<p>   должны инкапсулироваться в пакет, формат которого определяется выбранным</p>
<p>   методом. Подобно этому, когда данные для клиента получаются</p>
<p>   SOCKS-сервером, сервер должен инкапсулировать данные согласно тому,</p>
<p>   как это требует выбранный метод аутентификации.</p>
<p>7.  Процедура для клиентов работающих по UDP</p>
<p>   Клиент, работающий по UDP, должен посылать свои датаграмы на</p>
<p>   порт пересылающего их UDP-сервера, указанного в поле BND.PORT в</p>
<p>   ответе на запрос UDP ASSOCIATE. Если выбранная схема аутентификации</p>
<p>   требует особое формирование пакетов с целью проверки целостности</p>
<p>   и/или конфедициальности, датаграмма должна инкапсулироваться в пакет,</p>
<p>   формат которого определяется выбранной схемой. Каждая UDP-датаграма</p>
<p>   содержит в себе заголовок UDP-запроса:</p>
<p>Leech, et al                Standards Track                 [Страница 7]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>      +----+------+------+----------+----------+----------+</p>
<p>      |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |</p>
<p>      +----+------+------+----------+----------+----------+</p>
<p>      | 2  |  1   |  1   | Variable |    2     | Variable |</p>
<p>      +----+------+------+----------+----------+----------+</p>
<p>     Поля заголовка UDP-запроса:</p>
<p>          o  RSV  зарезервировано X'0000'</p>
<p>          o  FRAG    текущий номер фрагмента</p>
<p>          o  ATYP    тип адреса:</p>
<p>             o  IP v4 адрес: X'01'</p>
<p>             o  имя домена:  X'03'</p>
<p>             o  IP v6 адрес: X'04'</p>
<p>          o  DST.ADDR       требуемый целевой адрес</p>
<p>          o  DST.PORT       требуемый целевой порт</p>
<p>          o  DATA     пользовательские данные</p>
<p>   Когда пересылающий UDP-датаграммы сервер пересылает датаграмму, он</p>
<p>   делает это молча, без какого-либо уведомления выполнившего запрос</p>
<p>   клиента. Аналогично, сервер будет молча отбрасывать датаграммы,</p>
<p>   которые он не может или не будет пересылать. Когда пересылающий</p>
<p>   UDP-датаграммы сервер получает ответную датаграмму с удаленного</p>
<p>   хоста, он должен инкапсулировать эту датаграмму используя помимо</p>
<p>   заголовка UDP-запроса еще и инкапсуляцию, определяемую выбранной</p>
<p>   схемой аутентификации.</p>
<p>   Обращение к пересылающему UDP-датаграммы серверу должно производиться</p>
<p>   с ожидаемого SOCKS-сервером IP-адреса клиента, который (клиент) будет</p>
<p>   посылать датаграммы на BND.PORT, данный в ответе на UDP ASSOCIATE.</p>
<p>   Сервер должен отбрасывать датаграммы полученные с любого IP-адреса,</p>
<p>   отличного от того, что был записан для этой связи.</p>
<p>   Поле FRAG показывает, является ли эта датаграмма самостоятельной или</p>
<p>   же фрагментом. Если датаграмма - фрагмент, то установленный старший</p>
<p>   бит является признаком последнего фрагмента, в то время как значение</p>
<p>   X'00' показывает, что это обычная датаграмма. Значения от 1 до 127</p>
<p>   обозначают на позицию фрагменте в последовательности. Каждый</p>
<p>   получатель будет иметь REASSEMBLY QUEUE (очередь сборки) и REASSEMBLY</p>
<p>   TIMER (таймер сборки) связанные с такой фрагментной датаграммой.</p>
<p>   Очередь сборки должна быть переинициализирована и связанные с ней</p>
<p>   фрагменты выкинуты всякий раз при истечении таймера сборки или</p>
<p>   с приходом новой датаграммы, чье значение в поле FRAG меньше,</p>
<p>   чем наибольшее значение поля FRAG датаграмм, обработанных</p>
<p>   при сборке фрагмента. Таймер сборки должен быть не менее 5 секунд.</p>
<p>   Приложениям рекомендуется избегать фрагментацию везде, где только</p>
<p>   это возможно.</p>
<p>   Реализация фрагментации опциональна, в реализациях где фрагментация</p>
<p>   не поддерживается, должны отбрасываться любые датаграммы, у которых</p>
<p>   поле FRAG отлично от X'00'.</p>
<p>Leech, et al                Standards Track                 [Страница 8]</p>
<p>RFC 1928                    Протокол SOCKS 5                   Март 1996</p>
<p>   Программный интерфейс для UDP работающего через SOCKS должен сообщать</p>
<p>   о оставшемся свободном пространстве в буфере для UDP-датаграмы, которое</p>
<p>   меньше, чем действительный размер буфера, выделенный операционной</p>
<p>   системой:</p>
<p>          o  если ATYP равен X'01' - на 10+зависит_от_метода октетов меньше</p>
<p>          o  если ATYP равен X'03' - на 262+зависит_от_метода октетов меньше</p>
<p>          o  если ATYP равен X'04' - на 20+зависит_от_метода октетов меньше</p>
<p>   Иными словами, так как в заголовке UDP-запроса, включенного в датаграмму,</p>
<p>   нет информации о длинне данных, то приложение должно помнить об этом</p>
<p>   самостоятельно.</p>
<p>8.  Замечания по безопасности</p>
<p>   Этот документ описывает протокол для работы на прикладном уровне</p>
<p>   с файрволлами в IP-сетях. Безопасность такой работы в большой</p>
<p>   степени зависит от особенностей аутентификации и инкапсуляции</p>
<p>   методов, обеспеченных в конкретной реализации и выбранных</p>
<p>   во время соединения клиента с SOCKS-cервером.</p>
<p>   При выборе метода аутентификации администраторы должны проявить особое</p>
<p>   внимание.</p>
<p>   Careful consideration should be given by the administrator to the</p>
<p>   selection of authentication methods.</p>
<p>9.  Ссылки</p>
<p>   [1] Koblas, D., "SOCKS", Proceedings: 1992 Usenix Security Symposium.</p>
<p>Адрес автора</p>
<p>       Marcus Leech</p>
<p>       Bell-Northern Research Ltd</p>
<p>       P.O. Box 3511, Stn. C,</p>
<p>       Ottawa, ON</p>
<p>       CANADA K1Y 4H7</p>
<p>       Phone: (613) 763-9145</p>
<p>       EMail: mleech@bnr.ca</p>

