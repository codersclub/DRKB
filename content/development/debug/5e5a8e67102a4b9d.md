Delphi. Работа над ошибками
===========================

::: {.date}
01.01.2007
:::

Автор: Coder

В течение своей профессиональной деятельности программист вырабатывает
систему правил, которая позволяет ему не совершать допущенных ранее
ошибок и избегать потенциально опасных ситуаций. Ценность правил
заключается в том, что они ограждают программиста от не всегда очевидных
проблем, дают возможность писать единообразный код и дают возможность
поступать формально, тем самым, освобождая \"мыслительные\" ресурсы на
решение поставленной задачи.

Некоторые из рецептов моей кулинарной книги я хочу предложить на ваше
суждение. Очевидность этих правил зависит от вашей квалификации.
Согласие с ними зависит от вашей собственной системы. Их источником
послужили мой личный опыт и опыт ошибок начинающих программистов, каждое
поколение которых повторяет их, к сожалению, с завидной стабильностью .

Выработанные правила направлены на:

Повышение надежности работы программы, т.е. уменьшение вероятности
возникновения ошибки. Вероятность возникновения ошибки существует
всегда, никто не безгрешен (включая операционную систему). Задача
программиста - свести эту вероятность к минимуму.

Увеличение устойчивости программы - свойства, при котором она
возвращается в стабильное состояние после возникновения возмущения
(ошибки) (а не зависает, исчезает или уваливает операционную систему).

Написание единообразного и легко поддерживаемого кода.

Warnings and Hints

Компилятор Delphi снабжен \"анализатором\" качества кода. Он может
предупреждать о потенциально опасных или бессмысленных ситуациях. Не
пренебрегайте его услугами.

Правило:

Добивайтесь, что бы ваша программа компилировалась без предупреждений и
намеков. Даже если они не существенны, в последствии в их массе вы или
пользователи вашей библиотеки могут не заметить более важные
предупреждения.

Использование констант

Используйте именованные константы. Это увеличивает \"настраиваемость\"
исходного кода. А также избавляет от проблем связанных с изменением
значения константы в случае ее множественного вхождения.

Range Check и Integer Overflow Check

К сожалению, эти опции компилятора по умолчанию отключены в Delphi, и
многие разработчики не пользуются их услугами, а зря. Появления этих
ошибок говорит о наличии в программе семантических ошибок, таких как
неправильная индексация массива или использование несоответствующего
целочисленного типа. Последствия этих ошибок могут быть весьма коварны.
Я советую оставлять эти флаги всегда включенными, независимо от того -
это отладочная или \"финальная\" версия программы. Лучше иметь
неработающую программу (или ее часть), чем программу работающую
неправильно (IMHO).

Отключать их имеет смысл, когда нет возможности исправить эту ошибку,
как, например, в случае с ранними версиями VCL, скомпилированной с этими
опциями.

Будьте недоверчивы

Очень часто алгоритмы кодируются из расчета на \"нормальный\" режим
работы (достаточно ресурсов, присутствуют все необходимые компоненты,
пользователи нажимают правильные комбинации клавиш и т.д.). Такие
реализации очень плохо справляются с возникающими возмущениями. Во
избежание этих проблем следуйте следующим простым правилам:

Проверяйте значения переменных на допустимость. Особенно это касается
переменных типа указатель, процедурных переменных и объектов.

Защищайте пары выделение-освобождение ресурсов блоками try/finally.
Предполагайте, что исключение может произойти в любом операторе.

Используйте процедуру Assert для проверки условий, которые всегда должны
быть истинными.

Объем кода, добавленный для проверок и обработки ошибок, может достигать
порядка \"полезного\" кода! Но, такой стиль программирования является
необходимым условием при написании сложных систем. Что поделаешь, из
бревен небоскреб не построишь

Значения по умолчанию и \"неопределенные\" значения

В логике распределения значений для переменных всегда необходимо
предусматривать \"неопределенное\" значение и значение по умолчанию.
Отсутствие таких значений достаточно часто приводят к семантическим
ошибкам.

Правило №1:

Для указателей и объектов пустым значением должно являться значение nil.

Для числовых типов лучше всего резервировать значение ноль.

Для строковых переменных - пустая строка

Для перечислимых типов необходимо предусмотреть специальное значение.

Пример:

TDayOfWeek = (dwNone,dwSun,dwMon,dwTue,dwWen,dwThu,dwFri,dwSat);

Правило №2:

\"Неопределенными\" значениями лучше всего выбирать такие, чье двоичное
представление соответствует нулю (нулям). Это увеличивает устойчивость,
когда не выполнена начальная инициализация переменной, но произведена
инициализация блока памяти, в котором она размещается.

Пример

Для перечислимых типов \"неопределенное\" значение должно быть первым,
так как оно соответствует целочисленному нулю.

Инициализация переменных и полей

Неинициализированные переменные часто становятся причинами возникновения
ошибок-фантомов. Обычно они имеют нерегулярную природу, и их трудно
выявить в процессе отладки. Особенно катастрофичными могут быть
последствия при таком обращении с указателями.

Правило:

Для глобальных переменных: использовать типизированные константы,
инициализированные переменные или присваивать начальные значения
переменным в секции инициализации модуля.

Для локальных переменных: присваивать начальные значения в первых
строках процедуры или функции.

Для полей объектов: присваивать начальные значения полям в конструкторе
и не полагаться на то, что память, выделенная под объект,
инициализируется нулями.

Массивы, записи и выделенные блоки памяти очень удобно инициализировать
при помощи функции FillChar. Но, с появлением в Delphi \"управляемых\"
(manageable) типов (длинные строки, динамические массивы, варианты и
интерфейсы), пользоваться ей необходимо с четким пониманием.

Пример

    type
      TStrArray = array[1..10] of string;
    var
      A : TStrArray;
    ...
      FillChar(A, SizeOf(A), 0); 

В данном примере вызов процедуры FillChar проинициализирует строки
пустыми значениями, такой подход был нормальным в ранних версиях Delphi
и Borland Pascal, но недопустим в последних версиях, в которых тип
string по умолчанию соответствует типу LongString и суть указатель. Если
значения строк перед инициализацией были не пусты, то мы получим утечку
памяти.

Передача параметров

В Delphi параметры функций и процедур по умолчанию передаются по
значению. Т.е. для них выделяется область памяти в стеке или куче, куда
копируются оригинальные значения. При передаче параметров сложных типов
(запись, массив, строка, вариант) это сопряжено со значительными
расходами ресурсов, поэтому параметры этих типов желательно передавать
по ссылке, т.е. с использованием ключевых слов var или const. Замечено,
что наиболее типична эта ошибка при передаче параметра типа string.

Пример

procedure Proc(s : string); //Не очень хорошо

procedure Proc(const s : string); //Гораздо лучше

Функции, процедуры и состояния

Для начала словарь терминов:

Функция

\- это подпрограмма, задачей которой является получение (извлечение,
вычисление и т.д.) определенного значения на основании входных
параметров и текущего состояния системы.

Процедура

\- это подпрограмма, которая предназначена для выполнения каких либо
действий над системой, и соответственно изменяет состояние системы.

Просьба не путать эти определения с ключевыми словами function и
procedure.

Правило:

Подпрограмма должна быть либо функцией, либо процедурой. Не совмещайте
эти две задачи в одной подпрограмме, разделите ее на несколько
подпрограмм.

Контроль достижения предела

Исключения в обработчике события OnTimer

При написания обработчика события OnTimer компонента TTimer необходимо
учитывать, что возникновение исключения в нем для обычного Delphi
приложения без специализированной обработки исключений приведет к
выскакиванию диалога с сообщением об ошибке. Но это не останавливает
работу таймера. И если причина возникновения исключения устойчива, то
скоро вы увидите следующее сообщения и т.д., пока у системы не
закончатся какие-нибудь ресурсы.

Решить данную проблему можно несколькими способами:

Обрабатывать исключения непосредственно в обработчике события

    try
    except
      on E: Exception do Application.ShowException(E);
    end;

Использовать централизованный обработчик исключений, который фиксирует
их в протоколе или журнале, но не выдает никаких сообщений об ошибке.

Application.OnException := MyExceptionHandler;

Последний подход желательно использовать в серверных приложениях, когда
нет пользователя, который интерактивно взаимодействует с приложением.

Заключение

Правила приведенные в этой статье носят общий характер. Практически
всегда существуют исключения (такова природа правил J). Следование этим
правилам, позволило мне добиться разработки устойчивого и единообразного
кода.

Взято из <https://forum.sources.ru>
