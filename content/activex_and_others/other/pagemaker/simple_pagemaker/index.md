---
Title: Просто и ясно о PageMaker и Delphi
Date: 01.01.2007
Author: Дмитрий Кузан
---


Просто и ясно о PageMaker и Delphi
==================================

::: {.date}
01.01.2007
:::

Дорогие коллеги, данной статьей я хочу показать вам основные принципы
работы с Adobe Pagemaker из Delphi.

Итак небольшой экскурс -

Adobe Pagemaker - довольно распространенный в нашей стране пакет
издательской верстки, в основном он применяется в газетах и журналах для
подготовки материала к отпечатке в типографию. Данный пакет имеет в свое
роде некоторые преимущества перед например Microsoft Word - ом при
подготовке журнальных полос или верстке книг. На примере компонента
TKDPageMaker я хочу показать вам возможность управления данной
программой из Delphi.

Возможная область применения данного пакета - по работе мне приходилось
создавать отчеты в виде брошюр

Итак начнем.

В документации поставляемой фирмой Adobe к данному пакету написано что
PageMaker поддерживает динамический обмен данными (DDE) с любыми
приложениями.

В данном компоненте реализована 3 основных метода , это -

    Property PathPageMaker : String Read FPathPageMaker Write SetPathPageMaker;

метод служащий для указания пути к исполняемому файлу Pagemaker,
используется для того что-бы TDDEClientConv запустил данное приложение в
виде DDE сервера

    Property Enable : Boolean Read FEnable Write SetEnable; 

метод используется для запуска Adobe PageMaker , т.е фактически для
установки DDE соединения

    Property UnitMeasurement : TUnitMeasurement Read FunitMeasurement Write SetUnitMeasurement; 

метод определяет единицы измерения которыми будет оперировать PageMaker
при передаче команд. Например команда PageMaker Script Language PageSize
позволяет установить размер страницы как в миллиметрах так и в дюймах -
что бы не заботится об установки единиц измерения в командах и создан
этот метод позволяющий гибко реализовать задание размеров в той форме в
какой установил программист.

Реализация передач команд серверу

Для этого в компоненте в разделе реализована функция

    Procedure ExecuteMacroPM(Str:String); // Выполнить макрос

Которая в свою очередь вызывает метод TDDEClientConv.

К сожалению разработчики немного запутали передачу логических данных в
процедуры и функции Script Language и в разные функциях булевые значения
могут передаваться в виде \'0\' -логического \"НЕТ\" , так и в виде
строкового \".F.\" , \"OFF\" или \"False\"

В общем для обработки преобразования реализовано несколько функций

    // вернуть строковый On Off
    Function  ReturnOnOffStr(Value: Boolean) : String;
     
    // вернуть строковый .T..F.
    Function  ReturnTrueFalseStr(Value: Boolean) : String;
     
    // вернуть строковый 0 , 1
    Function  Return0_1Str(Value: Boolean) : String; 
     
    // более подробно смотрите в компоненте…

Реализация приема данных из DDE сервера

Запрос данных с сервера в компоненте к сожалению не реализован функцией
т.к. компонент в свое время был написан за два часа в очень скоростном
режиме, если вы обратите внимание на некоторые функции то запрос данных
с DDE сервера в них реализован примерно так

    var
    PcharReply : Array[0..1023] of char;
    begin
    PcharReply := DDE.RequestData('GetPMState');

В основе вызывается стандартная функция RequestData TDDEClientConv.Для
более подробной информацие обратитесь в справку по TDDEClientConv.

Обработка поступивших данных

Данные, поступившие от DDE сервера представляют собой строку параметров
заключенную в апострофы где передаваемые данные разделены запятыми.

Число параметров может колебаться в произвольной степени в зависимости
от функции Script Language.

Для чтение параметров создана функция

    // получить параметр вернутый PM по порядковому значению
    Function  EncodeParams(Value : PChar; NN : Integer) : String;

возвращающая параметр в виде строки, причем NN - является номером
параметра в переданном списке (причем для чтения самого первого
параметра нужно указать NN равным 0)

Команды и функции Script Language.

Основные команды и функции в компоненте реализованы с префиксом
\"PM\_\"\

Например

    // Установить текущую страницу публикации
    procedure PM_Page(const nPages  : Integer);  virtual;
    // Получить текущуу страницу в публикации
    Function  PM_GetPageNumber : TPageNumber;  virtual;
    // Получить количество страниц
    Function  PM_GetPages : Integer;   virtual;

В компоненте я постарался сохранить синтаксис команд Script Language т.е
команде Page Script Language соответствует PM\_Page компонента. Да и еще
более детальную информацию по Script Language можно прочитать в
Slguide.hlp. Это позволит вам написать функции и процедуры не
реализованные в этом компоненте, а может и создать свой.

Вот в принципе то и все. Удачи вам.

P.S. Хочу напоследок заметить что данный компонент не претендует на
завершенность и полную функциональность , многое в нем реализовано не
очень хорошо , но учитывая что он был создан для обкатки в короткие
сроки то для основ работы он подойдет.Так что критика приниматься не
будет.

<https://delphi.mtu-net.ru/zip/pagemaker.zip>

Дмитрий Кузан

<https://www.delphikingdom.com>
