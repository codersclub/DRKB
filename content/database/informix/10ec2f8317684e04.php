<h1>Краткое пособие по языку Informix-4GL</h1>
<div class="date">01.01.2007</div>

<div style="">...</div>

<p>Соглашения о Языке 4GL и Начальные Понятия.</p>

<p>Программа на языке 4GL может состоять из нескольких файлов (модулей) с исходными текстами на 4GL. К ней так же относятся файлы с описанием используемых экранных форм, которые компилируются отдельно. Имя каждого модуля должно иметь расширение .4gl (например, module1.4gl), а имя файла с описанием экранных форм должно иметь расширение .per (например, form2.per). <br>
Каждый модуль содержит описания переменных и несколько процедурных блоков function (подпрограммы) и report (блоки печати). В программе должен быть один блок main - главный блок, начинающийся с ключевого слова main. На него будет передаваться управление при старте программы. <br>
Формат записи операторов 4GL свободный. Можно писать все подряд на одной строке, один оператор на нескольких строках, слова операторов можно разделять произвольным количеством пробелов и комментариев. Никакими значками (типа ;) операторы разделять не нужно. Окончание операторов определяется по контексту. <br>
Весь набор ключевых слов языка зарезервирован, их нельзя занимать для других целей (на имена объектов и переменных 4GL). <br>
<p>Компилятору языка безразлично, большими или маленькими буквами пишутся операторы. Он их не различает.</p>

<p>
Комментарии обозначаются знаками:<br>
{ комментарий },<br>
или знаком # - до конца строки,<br>
или знаком -- (два знака минус) до конца строки.
</p>

<p>Объекты, Используемые в INFORMIX-4GL.</p>
<ol>
  <li>Объекты SQL:
    <ul>
    <li>Имя базы данных (database-name)
    <li>Имя таблицы (table-name)
    <li>Имя столбца (column-name)
    <li>Имя индекса (index-name)
    <li>Имя псевдотаблицы (view-name)
    <li>Имя синонима (synonim-name)
    </ul>
  </li>

  <li>Переменные 4GL       
    <ul>
    <li>простая переменная      
    <li>переменная типа "запись"
    <li>массив                  
    </ul>
  </li>

  <li>Программные:
    <ul>          
    <li>функция (function)
    <li>отчет (report)
    <li>метка (label)
    </ul>          
  </li>

  <li>Имена операторов и курсоров
    <ul>          
    <p>statement-id - изготовленный оператор
    <p>cursor-name  - курсор                
    </ul>          
  </li>

  <li>Объекты экранного обмена.
    <ul>          
    <li>window
    <li>form
    <li>screen-field
    <li>screen-record
    <li>screen-array
    </ul>          
  </li>
</ol>

<p>1. Идентификаторы INFORMIX.</p>

<p>Каждый объект 4GL имеет имя (идентификатор) - это слово, состоящее из букв, цифр, и знаков подчеркивания (_), начинающееся с буквы или знака (_). В INFORMIX-4GL не различаются маленькие и большие буквы. Поэтому i_Un103Tt и I_UN103TT - одно и тоже имя.</td></tr></table></div>

1. Области Действия Имен Переменных:<br>
&nbsp; &#183; Локальная переменная - объявлена внутри блока function, main, report. Действует внутри блока, в котором объявлена.<br>
&nbsp; &#183; Модульная переменная должна быть объявлена в самом начале модуля с исходным текстом вне любого блока report, function или main. Действует внутри всего модуля (за исключением блоков, в которых это имя переобъявлено и является для них локальным).<br>
&nbsp; &#183; Глобальные переменные - объявляются с помощью оператора GLOBALS в начале модулей. Действуют во всех модулях с исходным текстом, в которых есть соответствующее объявление этих переменных.<br>
2. Область действия имен КУРСОРОВ и Изготовленных Операторов от точки их объявления (DECLARE, PREPARE) и до конца модуля.<br>
3. Область действия имен Окон, Форм, Функций, Отчетов - во всей программе.<br>

<p>В Языке 4GL Есть Такие Операторы:</p>
<p>Операторы SQL</p>

<p>Организация программы:</p>
<p>MAIN</p>
<p>FUNCTION</p>
<p>REPORT</p>

<p>Объявления переменных:</p>
<p>DEFINE</p>
<p>GLOBALS</p>

<p>Присвоения:</p>
<p>LET</p>
<p>INITIALIZE</p>

<p>Программные:</p>
<p>CALL            EXIT            GOTO</p>
<p>RETURN          FOR             LABLE</p>
<p>CASE            WHILE           RUN</p>
<p>IF              CONTINUE        SLEEP</p>

<p>Перехват прерываний:</p>
<p>WHENEVER</p>
<p>DEFER</p>

<p>Динамическое создание операторов:</p>
<p>PREPARE         EXECUTE         FREE</p>

<p>Манипуляция "курсором":</p>
<p>DECLARE</p>
<p>OPEN            FOREACH                 PUT</p>
<p>CLOSE            FETCH                 FLUSH</p>

<p>Экранный обмен:</p>
<p>MENU                    OPEN FORM               DISPLAY ARRAY</p>
<p>OPTIONS                 DISPLAY FORM            SCROLL</p>
<p>OPEN WINDOW             CLOSE FORM              INPUT ARRAY</p>
<p>CURRENT WINDOW          DISPLAY                 PROMPT</p>
<p>CLEAR                   INPUT                   ERROR</p>
<p>CLOSE WINDOW            CONSTRUCT               MESSAGE</p>

<p>Генерация отчетов:</p>
<p>START  REPORT</p>
<p>OUTPUT TO  REPORT</p>
<p>FINISH REPORT</p>

<p>Типы Переменных и Операторы Описания Переменных в 4GL.</p>
<p>В языке 4GL имеются простые переменные, переменные типа запись и массивы.
<br>Простые переменные бывают следующих типов:</p>

<pre>
    INTEGER       CHAR(n)        DATE
    SMALLINT      DECIMAL(m,n)   DATETIME ед_врем1 TO ед_врем2
    REAL          MONEY(m,n)     INTERVAL ед_врем1 TO ед_врем2
    FLOAT
</pre>

где ед_врем1, ед_врем2 - единицы измерения времени
    {YEAR,MONTH,DAY,HOUR,MINUTE,SECOND,FRACTION(n)}

<p>где FLOAT = DOUBLE PRECISSION</p>

<p>Переменная типа запись описывается при помощи конструкции RECORD ... END RECORD или конструкции LIKE имя_таблицы.* <br>
<p>Переменная типа массив имеет описатель ARRAY [i,j,k] OF type, где type - тип простой переменной, конструкция RECORD, или конструкция ARRAY. <br>
<p>Для описания переменных служит оператор DEFINE:</p>

<pre>
DEFINE  simw char (200), j,i,k INTEGER, ff FLOAT
# Здесь объявлены символьная переменная simw длиной 200 байт,
# целые i,j,k, и ff - восьмибайтовое с плавающей точкой

DATABASE zawod
DEFINE doljno   RECORD
# объявляется запись doljno, состоящая из 4 простых переменных
                 dolzn CHAR(20),         # должность
                 zarplmin  LIKE kadry.zarplata,
                 zarplmax  money(16,2),  # зарплата
                 vakansii int            # вакансии
END RECORD      # Здесь заканчивается объявление записи doljno
# Переменную можно оъявить с ключевым словом LIKE column_name.
# переменная zarplmin получает такой же тип,  что  и  столбец
# zarplata таблицы kadry из базы данных zawod
DEFINE rrr RECORD LIKE kadry.*
#  Переменную типа запись тоже можно объявить с ключевым словом
#  LIKE. Здесь объявлена запись rrr, содержащая элементы, имею-
#  щие те  же  самые  названия и те же самые типы что и столбцы
#  таблицы kadry
</pre>

<p>Элементами записи могут быть массивы. Можно обьявить массив элементов типа RECORD.</p>

<pre>
DEFINE zap RECORD
         a LIKE kadry.tabnom,
         b array[8] OF REAL
       END RECORD,
  massiw ARRAY[2,15] OF RECORD
         kolwo INT,
         tip CHAR(8)
       END RECORD
#    massiw  объявлен как массив записей. Каждая запись состоит
#  из двух простых элементов - kolwo и tip
</pre>

<p>Индексы массивов пишутся в квадратных скобках. На элементы записей можно ссылаться по его имени, если не допускается двусмысленности, иначе их необходимо уточнять именем записи, отделяя его точкой (.) от простого имени.</p>

<pre>
#  присвоить значение элементу массива можно так:
LET   massiw[1,i+2].kolwo = zap.a + LENGTH(massiw[1,i+2].tip)
</pre>

<p>Для сокращения перечисления элементов в списках можно пользоваться нотацией (*). Например, strkt.* означает все элементы записи strkt. А так же нотацией THRU: (элементы записи от и до)</p>

<pre>
SELECT kadry.* INTO strkt.* FROM kadry WHERE kadry.tabnom=i+j
SELECT * INTO strukt.b THRU strkt.e FROM kadry
</pre>

<p>Глобальные переменные должны иметь одинаковые объявления GLOBALS во всех модулях программы (в которых используются). Проще всего это организуется так: заводится отдельный модуль, в котором ничего, кроме объявлений GLOBALS нет. А во всех остальных модулях программы ссылаются на этот файл. Ниже приводится пример объявления глобальных переменных в файле progrglob.4gl:</p>

<pre>
DATABASE zawod
 GLOBALS
  DEFINE zap RECORD LIKE kadry.*
  DEFINE ext_count INT
   . . .
 END GLOBALS
</pre>

<p>Тогда в остальные модули программы, где используются эти глобальные переменные, надо включить строчку</p>

<pre>
GLOBALS "progrglob"
  . . .
</pre>

<p>Подпрограммные Блоки (Функции).</p>
<p>В языке 4GL при программировании функций (подпрограмм) используются операторы function. Все аргументы функции должны быть объявлены. Аргументы передаются по значению. Если функция возвращает какие-либо значения, то при вызове ее нужно воспользоваться в операторе CALL предложением RETURNING с перечислением переменных, в которые возвращается значение. Ниже приводится соответствующий фрагмент программы.</p>

<pre>
FUNCTION stroka(rec)
DEFINE rec RECORD       i int, st char(256)  END RECORD
RETURN  st clipped,"автопробега"
END FUNCTION
 . . .
MAIN
 . . .
   CALL stroka(rec1.*) RETURNING simw
 . . .
   LET simw=stroka(7,"Привет участникам ")
#    Если функция возвращает одно значение, то ее имя мож-
#         но использовать в выражениях.
   MESSAGE simw
 . . .
END MAIN
</pre>

<p>На экране пользователь увидит:</p>

<pre>
&#1107;&#1027;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#8218;
&#1107;&#1033;   Привет участникам автопробега                        &#1107;&#1033;
&#1107;&#1033;                                                        &#1107;&#1033;
&#1107;&#1033;                                                        &#1107;&#1033;
&#1107;&#1033;                                                        &#1107;&#1033;
&#1107;&#1107;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#8222;
</pre>

<p>Примеры Использования Программных Операторов.</p>

<p>Оператор безусловного перехода действует в пределах модуля.</p>
<pre>
GOTO metka
 . . .
LABEL  metka:   . . .
</pre>

<p>Оператор выбора.</p>
<pre>
CASE
   WHEN iscreen=1
        current window is w1
   WHEN iscreen=2
        current window is w2
        let iscreen=1
   OTHERWISE
        current window is SCREEN
END CASE
CASE   (a+b)                  #    Другой формат оператора CASE
       WHEN  1
        message "a=",a
       WHEN  2
        message "b=",b
 END CASE
</pre>

<p>Условный оператор.</p>
<pre>
IF str = "завершить" OR y&lt;0 THEN exit program # Не забывайте в конце каждого условного # оператора ставить END IF. END IF
</pre>

<p>Оператор цикла.</p>
<pre>
  FOR I= i1 TO 23
  let a[i]=0
     if b[i]=100 then
         EXIT FOR
         END IF
  END FOR
</pre>

<p>Цикл "пока".</p>
<pre>
  WHILE ff &gt; 3 or nn="проба"
   PROMPT "Введите число " for n
   let i=n+1
   message "А у меня ",i,", больше.   Вы проиграли."
   SLEEP  5
   RUN "rm *" WITHOUT WAITING
  END WHILE
</pre>

<p>Динамическое Изготовление Операторов SQL. Курсоры.</p>
<p>Операторы PREPARE и EXECUTE предназначены для динамического (во время выполнения программы) изготовления и выполнения операторов языка SQL (не 4GL !!!). <br>
<p>В приведенном ниже фрагменте в ответ на запрос пользователь сможет ввести с клавиатуры строку с оператором языка SQL (Пусть, например, он введет строку: DROP DATABASE buhgalteriq). Программа изготовит из этой строки настоящий оператор и выполнит его с помощью оператора EXECUTE. Если при выполнении зарегистрирована ошибка, о чем сообщит установленный в отрицательное значение код завершения status, пользователя снова попросят ввести оператор.</p>

<pre>
DEFINE stroka char(200)</p>
  MAIN</p>
  . . .</p>
LABEL METK2: PROMPT "введите оператор языка SQL: " FOR stroka</p>
    WHENEVER ERROR CONTINUE     # Включить  режим   "В   случае</p>
                                # ошибки  продолжить выполнение</p>
                                # программы"</p>
    PREPARE st1 FROM stroka     # Изготовить оператор из</p>
                                # символьной строки</p>
    EXECUTE st1                 #   Выполнить изготовленный оператор</p>
    IF status&lt;0 THEN
      ERROR "ошибка номер ", status, " в вашем операторе"
      GOTO metk2
    END IF
    WHENEVER ERROR STOP # Восстановить режим
                        # "В случае ошибки прервать
                        # выполнение программы"
    . . .
  END MAIN
</pre>

<p>В системную переменную status помещается код выполнения каждого оператора 4GL (status=0 если все нормально, status&lt;0 если произошла ошибка). Переменная status может проверяться после любого оператора программы и в зависимости от ее значения могут предприниматься какие-либо действия.</p>

<p>Курсоры</p>
<p>Если запрос к таблице возвращает несколько (больше одной) строк, то для их обработки используется так называемый курсор - указатель во множестве строк, выбранных оператором SELECT. Оператором DECLARE объявляется курсор для запроса, оператором OPEN этот запрос фактически выполняется и выбранные строки выделяются. Курсор устанавливается на первую из выбранных строк. С помощью оператора FETCH вы можете брать очередную строку, на которую указывает курсор, и помещать ее в свои программные переменные. Курсор после этого смещается на следующую строку. <br>
<p>С помощью конструкции циклической FOREACH имя_курсора ... END FOREACH можно перебрать все строки, выбранные оператором SELECT. Оператор OPEN в этом случае не нужен.</p>

<pre>
  DATABASE zawod
  DEFINE zap RECORD LIKE kadry.*
  DECLARE curs1 CURSOR FOR
     select * from kadry where datarovd&gt;"9/25/1973"
 #  в цикле FOREACH выводим на экран все строки таблицы  kadry,
 #  в которых  столбец datarovd содержит дату после 25 сентября
 #  1973 года.
  FOREACH curs1 INTO zap.*      # Берем очередную строку и  по-
                                # мещаем ее в запись zap
  MESSAGE zap.*                 #  Выводим запись zap на экран
  PROMPT "Еще ?" FOR CHAR c
  END FOREACH                   #  Конец цикла FOREACH
</pre>

<p>В следующем примере строки выбираемые из  таблицы  kadry  через курсор curs2 помещаются в массив z1 (но не более 100 строк).</p>

<pre>
  DATABASE zawod<
  DEFINE z1 ARRAY[100] OF RECORD LIKE kadry.*, counter int
  DECLARE curs2 CURSOR FOR SELECT * FROM kadry
        WHERE datarovd&lt;"9/26/1973"
  OPEN curs2
  FOR counter="1" TO 100
    FETCH curs2 INTO z1[counter].* # взять очередную строку и поместить ее в следующий элемент
                                   # массива z1
    IF status="NOTFOUND" THEN      # если выбранные сроки кончились, закончить цикл
      EXIT FOR
    END IF
  END FOR
  LET counter="counter-1"
  MESSAGE "В массив z1 прочитано ",counter, " записей"
</pre>

<p>Этот пример демонстрирует еще одно использование переменной status. Если оператор FETCH пытается взять сроку из курсора когда тот уже пуст, то значение переменной status устанавливается равным символической константе NOTFOUND, имеющей значение 100. Поэтому можно проверять значение status после оператора FETCH и если оно равно 100, то прекратить чтение строк из опустевшего курсора. В данном примере пользователь сам должен ввести условия, по которым будут найдены строки в таблице ceh. Он, например, может ввести: "nomerceh&gt;15 and nomerceh&lt;23". Программа прицепит это условие к строке, в которой записан SELECT оператор, получит строчку "SELECT * FROM ceh WHERE nomerceh&gt;15 and nomerceh&lt;23", изготовит из нее оператор, и для этого изготовленного оператора SELECT объявит курсор. Дальше действия аналогичны предыдущему примеру.</p>

<pre>
DEFINE z2 ARRAY[100] OF RECORD LIKE ceh.*,
         counter int, simw char(200)
PROMPT "допишите оператор SELECT * FROM ceh WHERE " FOR simw
IF LENGTH(simw)=0 THEN
    LET simw="TRUE"
    END IF
LET simw="SELECT * FROM ceh WHERE ", simw CLIPPED
PREPARE st2 FROM simw
  DECLARE cs2 FOR st2
  let counter=1
  FOREACH cs2 INTO z2[counter].*
  LET counter=counter+1
  IF counter&gt;100 THEN
     EXIT FOREACH
     END IF
  END FOREACH
LET   counter=counter-1
MESSAGE "В массив z2 прочитано ",counter, " записей"
</pre>

<p>Программирование Экранного Обмена.</p>
<p>В любой момент времени на экране терминала существует ТЕКУЩЕЕ окно, через которое и выполняется ввод/вывод вашей программы. С окном связаны используемые при вводе и выводе атрибуты (например, green, revers, underline и т.п.) и номера строк окна, используемых операторами MESSAGE, PROMPT и ERROR для вывода. <br>
При открытии нового окна оно становится текущим и и весь ввод/вывод будет направляться уже в него. <br>
В окно можно вывести экранную форму, которая, представляет собой набор экранных полей, имеющих имена, и в эти поля (из этих полей), обращаясь к ним по имени, можно выводить (вводить) данные с помощью оператора DISPLAY (INPUT). Экранные поля можно объединять в экранные записи. Описание экранных полей и самой формы располагается отдельно от программы в файле описания экранной формы. <br>
<p>Ниже приведен пример программы, иллюстрирующий работу с окнами.</p>

<pre>
OPEN WINDOW wind1 AT 2,30 WITH 10 ROWS, 40 COLUMNS
     ATTRIBUTE(BORDER, REVERSE, MESSAGE LINE FIRST)
        # текущим окном является wind1
        . . .
OPEN WINDOW wind2 AT 5,15 WITH FORM "schoolp"
ATTRIBUTE(GREEN,PROMPT LINE LAST,
 MESSAGE LINE LAST, FORM LINE FIRST)
        # текущим окном является wind2
CLEAR  WINDOW wind1
        . . .
CURRENT WINDOW IS wind1
        # текущим окном является wind1
OPEN FORM form1 from "schoolp"  # Инициализировать форму form1
                                # Взяв ее описание из файла
                                # schoolp.frm
DISPLAY FORM form1      # Вывести форму form1 в текущее окно
                        # т.е. в wind1
</pre>


<p>В результате работы этих операторов  на  экране  терминала появится приблизительно такая картинка:</p>
<p>&#1107;'&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;'</p>
<p>&#1107;&#1113;          &#1107;'&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;' окно    &#1107;&#1113;</p>
<p>&#1107;&#1113;          &#1107;&#1113; значение  равно 8                       &#1107;&#1113;  ...&#1107;wind1               &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;'&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;'</p>
<p>&#1107;&#1113;    &#1107;&#1113;      цех   [  2] [литейный     ]      &#1107;&#1113;      &#1107;&#1113;&#1107;щ&#1107;&#8249;&#1107;&#8222;      &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;&#1113;  таб.номер [26         ]              &#1107;&#1113;      &#1107;&#1113; окно       &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;&#1113;  фамилия   [Петров У.Е.         ]     &#1107;&#1113;      &#1107;&#1113;  ...&#1107; wind2  &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;&#1113;  должность [бригадир            ]     &#1107;&#1113;      &#1107;&#1113;  &#1107;&#1033;        &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;&#1113;  зарплата  [$340         ]            &#1107;&#1113;&#1107;щ&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8249;&#1107;&#8222;&#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;&#1113; дата рождения [31.12.1952]            &#1107;&#1113;      &#1107;&#1113;         &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;&#1113;                                       &#1107;&#1113;      &#1107;&#1113;         &#1107;&#1113;</p>
<p>&#1107;&#1113;    &#1107;"&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;"</p>
<p>&#1107;&#1113;          &#1107;&#1113;  789                                    &#1107;&#1113;         &#1107;&#1113;</p>
<p>&#1107;&#1113;          &#1107;"&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;"</p>
<p>&#1107;&#1113;                                                                &#1107;&#1113;</p>
<p>&#1107;&#1113;   нет таких                                                    &#1107;&#1113;</p>
<p>&#1107;"&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;"</p>
<p>Операторы MENU. MESSAGE. PROMPT.</p>
<p>В результате работы фрагмента программы</p>
<p>let sta_return=podtwervdenie(" В самом деле решили закончить? ")</p>
<p>        ...</p>
<p>function podtwervdenie(stroka)</p>
<p>define stroka char(38) , kod_wozwr  int</p>
<p>  open window podtwervdenie AT 11,10 WITH 4 rows, 39 columns ATTRIBUTE(border)</p>
<p>  display stroka at 4, 2 attribute (reverse)</p>
<p>    menu " "</p>
<p>      command key("Y")     "   Yes   " "Действительно  Да."</p>
<p>        let kod_wozwr=1</p>
<p>        exit menu</p>
<p>      command key("N",ESC) "   No    " "Нет, вернуться обратно."</p>
<p>        let kod_wozwr=0</p>
<p>        exit menu</p>
<p>      command key("A")     "  Abort  " "Отменить. И кончить."</p>
<p>        let kod_wozwr=-1</p>
<p>        exit menu</p>
<p>    end menu</p>
<p>  close window podtwervdenie</p>
<p>  return kod_wozwr</p>
<p>end function</p>
<p>на экране в текущем окне появится такое меню</p>
<p>        +---------------------------------------+</p>
<p>        | :      Yes        No        Abort     |</p>
<p>        |Действительно  Да.                     |</p>
<p>        |                                       |</p>
<p>        | В самом деле решили закончить?        |</p>
<p>        +---------------------------------------+</p>
<p>Оператор OPTIONS</p>
<p>Оператор OPTIONS может установить новые режимы для ввода вывода, если вас не устраивают заданные по умолчанию.</p>
<p>OPTIONS     MESSAGE LINE 23,</p>
<p>     HELP    FILE "h4gl.txt",   HELP  KEY CONTROL-T,</p>
<p>     DISPLAY ATTRIBUTE(REVERSE, UNDERLINE)</p>
<p>Операторы MESSAGE, ERROR</p>
<p>Оператор MESSAGE выводит строку значений на экран на message line. Аргументами MESSAGE могут быть переменные и константы, но не выражения.</p>
<p>let ttmm=CURRENT</p>
<p>message "Московское время ", ttmm</p>
<p>error "Данных больше нет, прочитанно ", n, " строк"</p>
<p>Оператор ERROR делает тоже, что и MESSAGE, только со звонком  и с атрибутом REVERSE. Сообщение выводится на 24-ю строку экрана.</p>
<p>Оператор PROMPT</p>
<p>Оператор PROMPT выводит на экран display-list - список значений переменных и констант, и вводит после этого с клавиатуры значение в указанную вслед за ключевым словом FOR переменную.</p>
<p>PROMPT "Да или нет ?" FOR answer</p>
<p>        ON KEY (CONTROL-U)</p>
<p>           LET  answer=wozderv()</p>
<p>           EXIT PROMPT</p>
<p>END PROMPT</p>
<p>Можно включить в PROMPT  контрольные  блоки,  выполняющиеся при нажатии заданных клавиш. Если в данном примере  во  время ввода пользователь нажмет клавишу CTRL-U то выполнятся  операторы  из ON  KEY  предложения:  будет  вызвана функция wozderv() а затем</p>
<p>прерван оператор PROMPT, не завершив ввода.</p>
<p>Операторы обмена с экранной формой</p>
<p>DISPLAY и INPUT</p>
<p>Оператор DISPLAY выводит данные в поля экранной формы.</p>
<p>DISPLAY a,b,zap[i].nomerceh TO pole1,fscr.* ATTRIBUTE(BOLD)</p>
<p>Если имена выводимых переменных совпадают  с  именами  экранных полей  в  текущей  экранной  форме, то можно применить ключевое слово BY NAME.</p>
<p>DISPLAY BY NAME fio, dolvnostx</p>
<p>Оператор  INPUT  используется  для  ввода  значений  через поля экранной формы. Можно предусмотреть дополнительные действия при вводе.  Для  этого  в оператор можно включить контрольные блоки AFTER, BEFORE, ON KEY.</p>
<p>INPUT  kadr.* FROM fio, dolvnostx, nomerceh</p>
<p>     BEFORE FIELD nomerceh</p>
<p>        message "Сегодня обслуживаются цеха 5 и 6"</p>
<p>        sleep 2</p>
<p>        message ""</p>
<p>     AFTER FIELD nomerceh</p>
<p>        IF kadr.nomerceh &gt; 6 then</p>
<p>        MESSAGE "Нет такого цеха, повторите"</p>
<p>        NEXT FIELD NOMERCEH</p>
<p>        ENF IF</p>
<p>END INPUT</p>
<p>Фрагмент, реализующий окошко подсказки.</p>
<p>Ниже приведен пример программирования подсказки (в процессе интерактивного диалога) с использованием экранного массива. Таблица ceh содержит два столбца: номер цеха и его название. В приведенном фрагменте вызывается функция wyborceh, которая выводит содержимое таблицы ceh в экранный массив. Пользователь передвигает курсор на название нужного ему цеха и нажимает клавишу CR. Подпрограмма определяет номер цеха и возвращает его вызывающей программе.</p>
<p>DATABASE zawod</p>
<p> . . .</p>
<p>let nc= wyborceh()</p>
<p> . . .</p>
<p>  FUNCTION wyborceh()     #  Выбор цеха, для внесения изменений</p>
<p>  DEFINE counter  int</p>
<p>  DEFINE ceharr ARRAY[25] OF RECORD       # массив для хранения</p>
<p>         nomerceh  int,      # номерцеха    данных  из таблицы</p>
<p>         nameceh char(20)    # название цеха              ceh</p>
<p>         END RECORD</p>
<p># Открыть окно с рамкой и вывести в него экранную форму cehform</p>
<p>    OPEN WINDOW cehwind AT 4 ,6 WITH FORM "cehform"</p>
<p>         ATTRIBUTE(BORDER)</p>
<p># Объявить курсор для выбора содержимого из таблицы ceh</p>
<p>        DECLARE cehcurs CURSOR FOR</p>
<p>          SELECT * FROM ceh ORDER BY nomerceh</p>
<p>#  Выполнить запрос и все выбранные строки поместить в програм-</p>
<p>#  ный массив ceharr</p>
<p>        LET counter = 0</p>
<p>        FOREACH cehcurs INTO ceharr[counter+1].*</p>
<p>                LET counter = counter + 1</p>
<p>                IF counter &gt;=25 THEN   EXIT FOREACH   END IF</p>
<p>        END FOREACH</p>
<p># счетчик counter равен фактическому  числу  строк  выданных  в</p>
<p>#  курсор</p>
<p>        MESSAGE "Выберите цех и нажмите CR"</p>
<p>#  Вывести в экранный массив cehscreen в экранной форме cehform</p>
<p>#  counter первых строк из программного массива ceharr</p>
<p>        call set_count(counter)</p>
<p>        DISPLAY ARRAY ceharr TO cehscreen.*</p>
<p>        ON KEY (CONTROL-M) EXIT DISPLAY</p>
<p>        END DISPLAY</p>
<p># Прервать показ экранного массива при нажатии клавиши CR</p>
<p># закрыть окно с экранной формой cehform</p>
<p>CLOSE WINDOW cehwind</p>
<p>let counter=arr_curr()             #номер строки массива,</p>
<p>                                   #на котором нажато CR</p>
<p>RETURN ceharr[counter].nomerceh  #номер цеха,</p>
<p>                                 #на котором нажато CR</p>
<p>END FUNCTION</p>
<p>А это пользователь увидит на экране:</p>
<p>   &#1107;'&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;'</p>
<p>   &#1107;&#1113;  номер        цех            &#1107;&#1113;</p>
<p>   &#1107;&#1113;  [3  ] [токарный            ]&#1107;&#1113;</p>
<p>   &#1107;&#1113;  [4  ] [гараж               ]&#1107;&#1113;</p>
<p>   &#1107;&#1113;  [5  ] [конюшня             ]&#1107;&#1113;</p>
<p>   &#1107;&#1113;  [6  ] [столовая            ]&#1107;&#1113;</p>
<p>   &#1107;&#1113;  [   ] [                    ]&#1107;&#1113;</p>
<p>   &#1107;&#1113;  Выберите цех и нажмите CR   &#1107;&#1113;</p>
<p>   &#1107;"&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;"</p>
<p>Описание и компиляция экранных форм</p>
<p>В приведенном выше фрагменте использована экранная форма cehform.per. Ниже приведено ее описание. Это описание должно лежать в файле cehform.per и должно быть откомпилировано компилятором экранных форм INFORMIX'а form4gl. <br>
<p>Описание экранной формы cehform.per</p>
<p>DATABASE zawod</p>
<p>SCREEN</p>
<p>{</p>
<p>номер        цех</p>
<p>[f00] [f001                ]</p>
<p>[f00] [f001                ]</p>
<p>[f00] [f001                ]</p>
<p>[f00] [f001                ]</p>
<p>[f00] [f001                ]</p>
<p>}</p>
<p>TABLES</p>
<p>ceh</p>
<p>ATTRIBUTES</p>
<p>f00 =  ceh.nomerceh;</p>
<p>f001 = ceh.nameceh;</p>
<p>INSTRUCTIONS</p>
<p>screen record cehscreen[5] (ceh.*)</p>
<p>END</p>
<p>В  секции DATABASE указана база данных; в секции SCREEN  задана картинка, которая будет рисоваться на экране; В TABLES указываются таблицы, в ATRIBUTES указываются имена экранных полей, (и, возможно,  их атрибуты) а в INSTRUCTIONS объявлен экранный массив cehscreen в пяти строках из двух полей (nomerceh и nameceh)</p>
<p>В качестве примера ниже приводится функция,  реализующая  простейший калькулятор. Возвращает значение вычисленного выражения. Скомпилируйте  ее  самостоятельно  и посмотрите отладчиком, как она работает.</p>
<p>function kalkulator()           #       Калькулятор</p>
<p>define wyravenie, kalkulator char(64), kolichestwo int</p>
<p>define stroka_kalkulatora char(200)</p>
<p>define beep char(1)</p>
<p>let beep=ascii 7</p>
<p>open   window   kalkulator   at   2,2  with  form  "kalkulator"</p>
<p>attribute(border, form line first)</p>
<p> input by name wyravenie, kalkulator without defaults</p>
<p> before field kalkulator</p>
<p>   let stroka_kalkulatora=</p>
<p>   "select  count(*),",wyravenie," from systables"</p>
<p>   whenever error continue</p>
<p>   prepare kalkulqtor_operator from stroka_kalkulatora</p>
<p>   if status&lt;0 then display beep to kalkulator display "Неправильное выражение" to kalkulator next field wyravenie end if declare kalkulator cursor for kalkulqtor_operator foreach kalkulator into kolichestwo, kalkulator if status&lt;0 then display beep to kalkulator display "Неправильное выражение" to kalkulator next field wyravenie end if end foreach whenever error stop display kalkulator to kalkulator next field wyravenie end input close window kalkulator return kalkulator end function</p>
<p>Использованная в подпрограмме экранная форма должна быть описана в файле kalkulator.per и откомпилирована при помощи компилятора form4gl.</p>
<p>DATABASE formonly</p>
<p>SCREEN</p>
<p>{</p>
<p>        Калькулятор.            Чтобы закончить нажмите ESC</p>
<p>[wyravenie                                                    ]</p>
<p>[kalkulator                                                   ]</p>
<p>}</p>
<p>ATTRIBUTES</p>
<p>wyravenie =formonly.wyravenie;</p>
<p>kalkulator=formonly.kalkulator;</p>
<p>END</p>
<p>Пример программы, выдающей отчет</p>
<p>DATABASE zawod</p>
<p>MAIN</p>
<p>DEFINE zapisx record like kadry.*</p>
<p>DEFINE  simw char (200), zapr char (300),fn  char (18)</p>
<p>OPEN form maxprim from "maxprim"</p>
<p>DISPLAY form maxprim            # вывести экранную форму</p>
<p>CONSTRUCT BY NAME simw ON kadry.* # Введение критериев выбора</p>
<p>                                  # с экрана</p>
<p>LET zapr="select * from kadry  where ",</p>
<p>simw clipped," order by tabnom "</p>
<p>MESSAGE simw</p>
<p>PREPARE selpr FROM zapr           # Изготовление запроса</p>
<p>DECLARE qquer CURSOR FOR selpr    # Объявление курсора для него</p>
<p>DISPLAY "Не забудьте нажать CTRL-O" AT 2,40</p>
<p>PROMPT "Файл, куда выводить отчет? или CR, если на экран: "</p>
<p>                         FOR fn</p>
<p>IF length(fn)=0 then START REPORT kadryrep       # на экран</p>
<p>else                 START REPORT kadryrep TO fn # в файл</p>
<p>END IF</p>
<p>   # выполнить запрос и сбросить выбранные строки в отчет</p>
<p>   FOREACH qquer  into zapisx.*   # Очередную строку из курсора</p>
<p>   OUTPUT TO REPORT kadryrep(zapisx.*)  # поместить в отчет</p>
<p>   END FOREACH</p>
<p>FINISH REPORT kadryrep          # Вывести результаты отчета</p>
<p>END MAIN</p>
<p>REPORT kadryrep(z)</p>
<p>DEFINE nameceh like ceh.nameceh</p>
<p>DEFINE z record like kadry.*</p>
<p>   # nomerceh  int,          # номер цеха</p>
<p>   # tabnom    serial,       # табельн. номер</p>
<p>   # fio       char(20),     # фамилия</p>
<p>   # dolvn     char(20),     # должность</p>
<p>   # zarplata  money(16,2),  # зарплата</p>
<p>   # datarovd  date          # дата рожд.</p>
<p>        OUTPUT</p>
<p>left  margin 0</p>
<p>right margin 80</p>
<p>top   margin 0</p>
<p>bottom margin 0</p>
<p>page  length 23</p>
<p>       ORDER BY z.nomerceh, z.tabnom   # Упорядочить</p>
<p>                    FORMAT</p>
<p>PAGE HEADER</p>
<p>print "-------------------------------------------------------"</p>
<p>print "цех|таб.ном|фио       |должность   |зарплата| дата рожд"</p>
<p>print "_______________________________________________________"</p>
<p>ON EVERY ROW</p>
<p> print  z.nomerceh using "##", column 4,z.tabnom using "#####",</p>
<p> column 13,z.fio clipped,</p>
<p> column 28,z.dolvn clipped,</p>
<p> column 43,z.zarplata using "$####.##",</p>
<p> column 53,z.datarovd using "dd-mm-yyyy"</p>
<p>BEFORE GROUP OF z.nomerceh</p>
<p>select @nameceh into nameceh from ceh where nomerceh=z.nomerceh</p>
<p> skip to top of page</p>
<p> skip 1 line</p>
<p> print "Цех   ",nameceh</p>
<p> skip 1 line</p>
<p>AFTER GROUP OF  z.nomerceh</p>
<p> need 2 lines</p>
<p> print " В цехе ",nameceh clipped,2 spaces,</p>
<p>       group count(*) using "#####" ," человек, "</p>
<p> print " Средняя зарплата ",</p>
<p>       group avg(z.zarplata) using "##### руб.## коп"</p>
<p>PAGE TRAILER</p>
<p> print "заполнена страница номер", pageno</p>
<p> pause "нажмите ВВОД"</p>
<p>END REPORT</p>

<p>Вот что увидит на пользователь во время работы программы:</p>
<p>+-------------------------------------------------------------+</p>
<p>|Укажите файл, куда выводить отчет, или CR, если на экран:    |</p>
<p>|                                 Не забудьте нажать CONTROL-О|</p>
<p>|                                                             |</p>
<p>|----------------------------------------------               |</p>
<p>|     цех   [1:4] [                     ]                     |</p>
<p>| таб.номер [           ]                                     |</p>
<p>| фамилия   [*ов                 ]                            |</p>
<p>| должность [                    ]                            |</p>
<p>| зарплата  [&gt;500         ]                                   |</p>
<p>|дата рождения [          ]                                   |</p>
<p>|                                                             |</p>
<p>|                                                             |</p>
<p>nomerceh between 1 and 4 and fio matches "*о*" and zarplata&gt;500</p>
<p>|                                                             |</p>
<p>+-------------------------------------------------------------+</p>
<p>---------------------------------------------------------------------------</p>
<p>цех|таб.ном|фио            |должность     |зарплата| дата рожд</p>
<p>_______________________________________________________________</p>
<p>Цех   дирекция</p>
<p> 1    34    иванов         директор       $ 4000.00</p>
<p> 1    35    кононов        зав. по снабжению$ 4000.00</p>
<p> В цехе дирекция      2 человек,</p>
<p> Средняя зарплата   4000 руб.00 коп</p>
<p>заполнена страница номер          1</p>
<p>нажмите ВВОД</p>
<p>---------------------------------------------------------------------------</p>
<p>цех|таб.ном|фио            |должность     |зарплата| дата рожд</p>
<p>_______________________________________________________________</p>
<p>Цех   литейный</p>
<p> 2    12    окунев         рабочий        $ 2000.00</p>
<p> 2    14    липко          лаборант       $ 2000.00</p>
<p> 2    18    пухов          мастер         $ 2000.00</p>
<p> 2    21    сухов          рабочий        $ 2000.00</p>
<p> 2    24    угольков       рабочий        $ 2000.00</p>
<p> В цехе литейный      5 человек,</p>
<p> Средняя зарплата   2000 руб.00 коп</p>
<p>заполнена страница номер          2</p>
<p>нажмите ВВОД</p>
<p>---------------------------------------------------------------------------</p>
<p>цех|таб.ном|фио            |должность     |зарплата| дата рожд</p>
<p>_______________________________________________________________</p>
<p>Цех   гараж</p>
<p> 4     9    потруев        слесарь        $ 1230.00</p>
<p> 4    12    гундосов       шофер          $ 2000.00</p>
<p> В цехе гараж      2 человек,</p>
<p> Средняя зарплата   1615 руб.00 коп</p>
<p>заполнена страница номер          3</p>
<p>нажмите ВВОД</p>
<p>Описание экранной формы</p>
<p>Описание состоит из 5 разделов: DATABASE, SCREEN, TABLES, ATTRIBUTES, INSTRUCTIONS</p>
<p>#  база данных, с которой ведется работа</p>
<p>DATABASE zawod</p>
<p>#  Картинка, которая выводится на экран.</p>
<p>#  экранные поля обозначены так:    [метка поля  ]</p>
<p>#  метка поля используется в разделе ATTRIBUТЕ</p>
<p>SCREEN</p>
<p>{</p>
<p> номер цеха [nceh  ]             зарплата   [f002       ]</p>
<p> фамилия    [fio                 ]</p>
<p> должность  [dol                 ]</p>
<p>                  Так в экранной форме рисуется рамка.</p>
<p>  Значок \g используется для входа и выхода в графический режим</p>
<p>                    \gp-----------------------------q\g</p>
<p>                    \g|\g Экранный массив         \g|\g</p>
<p>                    \g|\g [s1     ]  [s2            ] \g|\g</p>
<p>                    \g|\g [s1     ]  [s2            ] \g|\g</p>
<p>                    \g|\g [s1     ]  [s2            ] \g|\g</p>
<p>                    \g|\gномер цеха  название цеха    \g|\g</p>
<p>                    \gb-----------------------------d\g</p>
<p>        в графическом режиме символы р q b d - |  заменяются</p>
<p>        символами рисования рамки    &#1107;' &#1107;' &#1107;" &#1107;" &#1107;&#8250; &#1107;&#1113;</p>
<p>}</p>
<p>TABLES          #  имена таблиц, с которыми ассоциированна форма</p>
<p>  kadry</p>
<p>  ceh</p>
<p>ATTRIBUTES      # Имена экранных полей в форме и их атрибуты.</p>
<p># слева от знака (=) пишется метка поля (которая  фигурирует  в</p>
<p># разделе SCREEN), справа - имя экранного поля, которое обычно,</p>
<p># для удобства, должно совпадать с именем какого-нибудь столбца</p>
<p># из таблиц, перечисленных в разделе TABLES</p>
<p>nceh     = kadry.nomerceh;</p>
<p>f002     = zarplata, COLOR=REVERSE WHERE f002 &gt;500;</p>
<p>#  если в поле выведено значение больше 500, то оно будет</p>
<p>#  выделено с атрибутом  REVERSЕ (негатив)</p>
<p>fio  = fio;</p>
<p>dol  = dolvn, comments="Проверьте наличие в штатном расписании";</p>
<p>s1      = ceh.nomerceh;</p>
<p>s2      = ceh.nameceh;</p>
<p>                            #  здесь экранные поля можно</p>
<p>INSTRUCTIONS                #  объединить в экранные записи</p>
<p>    screen record   kad (kadry.nomerceh, dolvn, zarplata)</p>
<p>                #  и описать экранные массивы</p>
<p>    screen record   scr[3] (ceh.nomerceh, nameceh)</p>
<p>END</p>

<p>а вот что увидит на экране пользователь, использующий эту форму:</p>

<pre>
&#1107;'&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;'
&#1107;&#1113;   номер цеха [      ]            зарплата   [f002       ]           &#1107;&#1113;
&#1107;&#1113;   фамилия    [                    ]                                 &#1107;&#1113;
&#1107;&#1113;   должность  [                    ]                                 &#1107;&#1113;
&#1107;&#1113;                    Так в экранной форме рисуется рамка.             &#1107;&#1113;
&#1107;&#1113;    Значок  используется для входа и выхода в графический режим      &#1107;&#1113;
&#1107;&#1113;                      &#1107;'&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;'
&#1107;&#1113;                      &#1107;&#1113;   Экранный массив             &#1107;&#1113;            &#1107;&#1113;
&#1107;&#1113;                      &#1107;&#1113;   [       ]  [              ] &#1107;&#1113;            &#1107;&#1113;
&#1107;&#1113;                      &#1107;&#1113;   [       ]  [              ] &#1107;&#1113;            &#1107;&#1113;
&#1107;&#1113;                      &#1107;&#1113;   [       ]  [              ] &#1107;&#1113;            &#1107;&#1113;
&#1107;&#1113;                      &#1107;&#1113;   номер цеха  название цеха   &#1107;&#1113;            &#1107;&#1113;
&#1107;&#1113;                      &#1107;"&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;"
&#1107;&#1113;          в графическом режиме символы р q b d - |  заменяются       &#1107;&#1113;
&#1107;&#1113;          символами рисования рамки    &#1107;' &#1107;' &#1107;" &#1107;" &#1107;&#8250; &#1107;&#1113;             &#1107;&#1113;
&#1107;"&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;&#8250;&#1107;
</pre>

<p>В этой экранной форме определены экранные поля: kadry.nomerceh, zarpllatа, fiо, dolvп, ceh.nomerceh, nameceh</p>

<p>А так же экранные записи: kadrу (по умолчанию), ceh (по умолчанию), kad, scr[3]</p>
