---
Title: Shell Extensions и как с ними бороться (статья)
Date: 01.01.2007
---


Shell Extensions и как с ними бороться (статья)
===============================================

::: {.date}
01.01.2007
:::

Shell Extensions и как с ними бороться

Думаю, вы замечали, что некоторые программы добавляют собственные пункты
в системное контекстное меню. Например, WinRAR добавляет \"Сжать\" и
\"Распаковать в...\", ICQ - \"Переслать пользователю\" и пр. Механизм, с
помощью которого ваш код \"внедряется\" в оболочку Windows, называется
Shell Extensions - именно о нем пойдет речь...

Определения

В дальнейшем, говоря \"программист среднего уровня\", мы будем
подразумевать человека, который уже написал свой первый текстовый
редактор и знаком с практикой создания собственных компонент.

![clip0244](/pic/clip0244.gif){width="140" height="146"}

Shell Extensions - набор сервисных функций Windows API, призванный
обеспечить расширение базовых функций оболочки Windows Explorer за счет
наших надстроек. В числе основных функций Shell Extensions:

  --- ----------------------------------------
  ·   работа с системными контекстными меню;
  --- ----------------------------------------

  --- ---------------------------------------------------------------------------------------------------------------------
  ·   работа с папками и объектами из пространства имен оболочки Windows (Мои Документы, Принтеры, Панель управления...);
  --- ---------------------------------------------------------------------------------------------------------------------

  --- ------------------------------------
  ·   использование механизма Drag&Drop;
  --- ------------------------------------

  --- -----------------------------------
  ·   создание и использование ярлыков.
  --- -----------------------------------

Итак...

Для реализации задуманного нам понадобятся интерфейсы IContextMenu и
IShellFolder. Указатель на главный интерфейс IshellFolder,
соответствующий \"Рабочему столу\" оболочки, можно получить, используя
функцию SHGetDesktopFolder, объявление которой выглядит так:

    function SHGetDesktopFolder (var ppshf: IShellFolder): HResult; stdcall; 

 \

Эта функция возвращает нам указатель на интерфейс IShellFolder, который
возвращается в переменной ppshf. Далее допустим, что у нас в компоненте
имеется поле под названием ShellObject типа String, в котором хранится
путь к необходимому объекту (к примеру - C:\\Windows\\NotePad.exe), и
что нам нужно получить его контекстное меню (рис. 2).

![clip0245](/pic/clip0245.gif){width="120" height="207"}

Для этого сначала используем метод из интерфейса IShellFolder:

    function GetUIObjectOf (hwndOwner: HWND; cidl: UINT; var apidl: PItemIDList;const riid: TIID; prgfInOut: Pointer; out ppvOut): HResult; stdcall; 

Параметры:

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ------------------------------------------------
  ·   hwndOwner - дескриптор родительского окна (0);
  --- ------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -----------------------------------------------------------------------
  ·   cidl - количество элементов, на которое указывает значение apidl (1);
  --- -----------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- --------------------------------------------------------------------------
  ·   apidl - параметр, представляющий собой уникальный идентификатор объекта;
  --- --------------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -----------------------------------------------------------------------------------------------------
  ·   riid - глобальный уникальный идентификатор системы Windows (IID\_IContextMenu из файла ShlObj.pas);
  --- -----------------------------------------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -----------------------------------------------
  ·   prgfInOut - зарезервировано, должно быть nil;
  --- -----------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -----------------------------------------------------------------------------
  ·   ppvOut - переменная, которая получит указатель на \"заказанный\" интерфейс.
  --- -----------------------------------------------------------------------------
:::

После использования этого оператора нам понадобится обратиться к
функциям WinAPI - для работы с контекстными меню. Это, в первую очередь:

    Function CreatePopupMenu: HMENU; stdcall; 
    Function TrackPopupMenu (hMenu: HMENU; uFlags: UINT; x, y, nReserved: Integer;hWnd: HWND; prcRect: PRect): BOOL; stdcall; 
    Function DestroyMenu (Menu:HMENU):LogBool; stdcall; 

Синтаксис первой и последней функции, я думаю, понятен и без
разъяснений. Функция TrackPopupMenu, собственно, и выводит на экран
контекстное меню. Параметры этой функции принимают значения:

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ---------------------------------------------------------------------------------------------------------
  ·   hMenu - дескриптор контекстного меню. Это тот самый Menu, который мы создали с помощью CreatePopupMenu;
  --- ---------------------------------------------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ·   uFlags - выравнивание относительно координат. Возможные значения: TPM\_CENTERALIGN, TPM\_LEFTALIGN, TPM\_RIGHTALIGN, TPM\_LEFTBUTTON, TPM\_RIGHTBUTTON, TPM\_RETURNCMD. Этот параметр используется для возврата команды (как будет показано ниже);
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ---------------------------------------------------------------
  ·   x, y - координаты, по которым будем \"впрыгивать\" наше меню;
  --- ---------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- --------------------------------------------------
  ·   nReserved - соответственно, приравниваем к нулю;
  --- --------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ---------------------------------------
  ·   hWnd - дескриптор родительского окна;
  --- ---------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ·   prcRect - указатель на структуру TRect, которая задает \"окно\" в экранных координатах в пределах которого пользователь может щелкать без каких-либо исчезновений контекстного меню. Если = nil, то при нажатии мышкой за пределами контекстного меню оное исчезнет.
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
:::

Возвращаемое значение показывает наличие команды или ее отсутствие. Если
True - пользователь выбрал пункт; False - соответственно, не выбрал.

А теперь - самое главное

Ну что ж, сделали мы Menu - остается наполнить его содержимым,
соответствующим нашему ShellObject. Для этого узнаем сначала его
идентификатор (PItemIDList) - сделаем это при помощи метода
ParseDisplayName из интерфейса IshellFolder. Этот метод объявлен
следующим образом:

    function ParseDisplayName (hwndOwner: HWND;
                               pbcReserved: Pointer; 
                               lpszDisplayName: POLESTR; 
                           out pchEaten: ULONG;
                           out ppidl: PItemIDList; 
                           var dwAttributes: ULONG): HResult; stdcall; 

Расклад такой:

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ---------------------------------------------------------------------
  ·   lpszDisplayName - имя объекта, для которого надо найти PItemIDList;
  --- ---------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ------------------------------------------------------------------
  ·   pchEaten - возвращает символы, которые были правильно разобраны;
  --- ------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- --------------------------------------------------------------
  ·   ppidl - как раз то, что нам нужно (сохраняем в FItemIDList);
  --- --------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------
  ·   dwAttributes - атрибуты для только что найденного FItemIDList.
  --- ----------------------------------------------------------------
:::

Но здесь следует проявлять осторожность. Как вы помните, нам нужно
вывести контекстное меню для C:\\Windows\\NotePad.exe. Но сделать это
прямо нельзя. Поэтому найдем сначала PItemIDList для папки C:\\Windows -
контейнера нашего NotePad.exe. Пишем:

    OleCheck (ShellFolder.ParseDisplayName (Handle,nil,StringToOleStr (ExtractFileDir (ShellObject)), FEaten,FItemIDList,FAtt)); 

где:

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- --------------------------------------------------------------------
  ·   ShellFolder - значение, которое мы получили из SHGetDesktopFolder;
  --- --------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------------------------------------------------------
  ·   FEaten,FAtt - как я уже говорил, мне они не пригодились - но, чем черт не шутит, лучше их все-таки придержать;
  --- ----------------------------------------------------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- --------------------------------------------------
  ·   FItemIDList - сохраняем, он нам еще понадобится.
  --- --------------------------------------------------
:::

После удачного завершения надо бы перейти к классу родителя нашего
NotePad.exe. Воспользуемся для этого функцией IShellFolder.BindToObject,
объявленной следующим образом:

    Function BindToObject (pidl: PItemIDList; pbcReserved: Pointer;const riid: TIID; out ppvOut): HResult; stdcall; 

Тут:

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -------------------------
  ·   pidl - наш FItemIDList;
  --- -------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------
  ·   riid - в этом случае указывает на экземпляр IID\_IshellFolder;
  --- ----------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -------------------------------------------------------------------
  ·   ppvOut - указывает, куда нам его запихнут (скажем, ShellFolder1).
  --- -------------------------------------------------------------------
:::

И после очередной строчки кода:

    OleCheck (ShellFolder.BindToObject (FItemIDList,nil,IID_IShellFolder,ShellFolder0));

мы получим в переменной ShellFolder0 указатель на интерфейс
IShellFolder, соответствующий папке C:\\Windows. Теперь мы можем узнать
PItemIDList нашего NotePad:

    OleCheck (ShellFolder0.ParseDisplayName (Handle,nil,StringToOleStr (ExtractFileName (ShellObject)),FEaten,FItemIDList,FAtt)); 

Для чего все это было написано?

Теперь мы без зазрений совести можем приступать к выводу нашего
контекстного меню:

    OleCheck (ShellFolder0.GetUIObjectOf
    (Handle,1,FItemIDList,IID_IContextMenu,nil,ICM));
    Menu:=CreatePopupMenu;
    Try
    ICM.QueryContextMenu (Menu,1,$7FFF,CMF_EXPLORE
    or CMF_CANRENAME);
    Command:=TrackPopupMenu (Menu, TPM_LEFTALIGN or
    TPM_LEFTBUTTON or TPM_RETURNCMD,100,100,0,Handle,nil);
    If Command then
    Begin
    ICmd:=Longint (Command)-1;
    OleCheck (ICM.GetCommandString
    (ICmd,GCS_VERBA,nil,CommandStr,SizeOf (CommandStr)));
    CHandled:=False;
    DoCommandEvent (StrPas (CommandStr),CHandled);
    if not CHandled then
    begin
    FillChar (ICI,SizeOf (ICI),#0);
    ICI.cbSize:=SizeOf (ICI);
    ICI.hwnd:=Handle;
    ICI.lpVerb:=MakeIntResource (ICmd);
    ICI.nShow:=SW_SHOWNORMAL;
    OleCheck (ICM.InvokeCommand (ICI));
    end;
    End;
    Finally
    ICM:=nil;
    End;

Что тут написано. Во-первых - вызов интерфейса IcontextMenu,
сопряженного с объектом FItemIDList папки ShellFolder0. Во-вторых,
создание дескриптора пустого контекстного меню; заполнение контекстного
QueryContextMenu; использование команды TrackPopupMenu для вывода
контекстного меню в точку (100, 100).

Обработка результата команды TrackPopupMenu:

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ---------------------------------------------------------------
  ·   переменная Command типа LongBool преобразуется в тип Longint;
  --- ---------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------
  ·   CommandStr - переменная, в которую заносится название команды;
  --- ----------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -----------------------------------------------
  ·   DoCommandEvent - процедура обработки события;
  --- -----------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------
  ·   структура ICI типа \_CMINVOKECOMMANDINFO задает параметры, необходимые для запуска на исполнение кода, приписанного выбранному пункту меню по умолчанию;
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------
:::

::: {style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 0px;"}
  --- -------------------------------------------------
  ·   InvokeCommand (ICI) - запуск кода по умолчанию.
  --- -------------------------------------------------
:::

Недоработки...

...а где их нет? То есть, конечно, этот компонент работает, я его
использую, но в нем (пока) отсутствуют некоторые полезные функции. К
примеру, если вы заглянете в файл ShlObj.pas, то обнаружите, что там,
помимо использованного нами интерфейса IcontextMenu, объявлены также
интерфейсы IContextMenu2 и IContextMenu3, которые используются для
расширения базовых функций интерфейса (к примеру, IContextMenu2
используется для работы с элементами подменю). Кроме того, небольшая
доработка компонента даст возможность включать в него свои собственные
пункты меню (сравните рис. 3 и рис. 4).

![clip0247](/pic/clip0247.gif){width="120"
height="204"}![clip0246](/pic/clip0246.gif){width="120" height="251"}

Так что не стоит рассматривать эту статью как исчерпывающее руководство
по Shell Extensions - она призвана всего лишь пробудить в вас аппетит к
дальнейшим исследованиям.

 \
2004.05.07 Автор: Михаил Продан\
<https://www.cpp.com.ua>

 \
