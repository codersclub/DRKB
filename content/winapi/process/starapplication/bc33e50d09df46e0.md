Процессы, потоки и функции ShellExecute и WinExec
=================================================

::: {.date}
01.01.2007
:::

Устройство Windows. Процессы, потоки и функции ShellExecute и WinExec.
Часть 1.

    По просьбам общественности и была написана эта статья.

Действительно невозможно профессионально разрабатывать многопоточные
программы,

не зная, что такое процессы, потоки, нити и синхронизация (надеюсь
посвятить этому одну из следующих статей) и,

не представляя, как они работают. В статье за основу взята операционная
система Windows 2000.

Так же в этой статье будут подробно рассмотрены различные методы запуска
новых процессов (программ).

    Главным обстоятельством является то, что почти все современные ОС
многозадачны.

ОС Windows 2000 не является исключением, в ней может работать
одновременно несколько программ.

Любая программы имеет, по крайней мере, одним программным потоком,

который в свою очередь может создавать еще несколько потоков и т.д.

Но, не смотря на то, что ОС, называется \"многозадачной\" в конкретный
момент времени

выполняется только один поток. что вы не замечаете, как ОС переключается
между потоками.

Не стоит забывать, что, распределяя процессорное время, операционная
система Windows,

имеет дело именно с потоками, а не с процессами, которым эти потоки
принадлежат.

    Запуская программу в Windows, вы создаете процесс.

И в этом нет ничего удивительного, потому что в других операционных
системах происходит почти то же самое.

Однако все же процесс в Windows, например, отличается от процесса в
Unix.

А все дело в том, что в Windows процесс владеет открытыми файлами,
оперативной памятью и другими ресурсами.

Для каждого процесса (программы) Windows выделяет виртуальное адресное
пространство объемом 2 Гб.

Для адресации этого пространства используются обычные 32-битные
указатели,

которые представляют собой числа от 0 до 2 Г. Но процесс в Windows не
исполняется.

Исполняется программный поток. Поток - это последовательность машинных
команд, которые Windows

воспринимает, как единое целое (набор регистров процессора).

Поток обладает указателем на команду, которая в данный момент
выполняется,

и указателем на стек где хранятся локальные переменные потока.

Так в чем же разница спросите вы, между процессом и потоком, если
запущенная программа имеет только один,

программный поток то разницы практически никакой. Однако поток может
создавать другие потоки.

А те потоки могут создавать еще потоки. Два процесса ни могут иметь
общие ресурсы,

если не используют специальные механизмы межпроцессорного
взаимодействия.

В противоположность этому все потоки, которые принадлежат одному
процессу,

имею доступ ко всем ресурсам этого процесса.

    Зачем процессу несколько потоков? Потоки могут выполнять какие-то
действия параллельно

основной программе (в фоновом режиме). Потоки удобно применять, если
нежелательна

блокировка основной программы определенной функцией. Например, в то
время, как поток

осуществляет сложные математические вычисления, в главной программе
происходит подготовка

следующего задания и ввод параметров.

    Если вам нужно запустить новую программу, вам нужно создать новый
процесс.

Для этой цели служит системный вызов CreateProcess.

Однако использование этого вызова не очень удобно, потому что приходится
задавать множество аргументов,

однако в некоторых случаях без него не обойтись.

Если же вам надо просто запустить программу или открыть файл,

то для этого подходят мене сложные вызовы.

    Легче всего использовать WinExec. Однако Microsoft не рекомендует
его использование,

а предлагает пользоваться CreateProcess.

Но для выполнения тех или иных задач он вполне подходит.

Почему же нежелателен вызов WinExec дело все в том, что фактически он
содержит обращение

к еще одному устаревшему системному вызову LoadModule, который
обращается к CreateProcess

со значениями аргументов по умолчанию. При обращении к WinExec
необходимо задать полный путь

к программе или имя EXE файла, расположенного в пути поиска, а также
способ

отображения программы (константы SW\_HIDE, SW\_SHOW и т.д. см. Таблица
2).

    Если вызов функции произошел успешно, то WinExec вернет дескриптор
новой

программы (который не может быть меньше 32, т.е. если WinExec возвращает
число меньше 32,

то вызов привел к ошибке, коды ошибок см. Таблица 1).

Таблица 1.

0 Системе не хватает ресурсов.

ERROR\_BAD\_FORMAT Некорректный EXE файл (не Win32 EXE файл или EXE файл
поврежден).

ERROR\_FILE\_NOT\_FOUND Указанный файл не найден.

ERROR\_PATH\_NOT\_FOUND Указанный путь не найден.

    Еще один простой вызов это - ShellExecute. Этот вызов во многом
напоминает WinExec,

однако он поддерживает обработку типов файлов, зарегистрированных в
Windows.

Например, если вы с помощью ShellExecute вы попробуете запустить файл с
расширением .BMP,

то буде запущена программа Paint или любая другая, которая использует
для просмотра графических файлов.

В качестве аргументов ShellExecute принимает дескриптор окна (если есть
необходимость в сообщениях об ошибках),

строку, такую как open (открыть), print (напечатать) и explore
(исследовать), можно в качестве этой строки передать NULL,

тогда файл указанный вами будет открыт (open). Так же ShellExecute
необходимо сообщить имя файла и любые параметры

командной строки (чаще всего NULL), и оставшиеся два аргумента это
текущий каталог и константа функции

ShowWindow (как и в WinExec см. Таблица 2).

Таблица 2.

SW\_HIDE Окно в скрытом режиме.

SW\_MAXIMIZE Окно максимального размера

SW\_MINIMIZE Окно находится в свернутом виде, активируется следующее
верхнее окно в Z последовательности.

SW\_RESTORE Активирует и показывает окно. Если окно свернуто или
развернуто, Windows восстанавливает его

к первоначальному размеру и позиции. Приложение должно определить этот
флаг при восстановлении свернутого окна.

SW\_SHOW Активирует окно и выводит его в текущих размерах и позиции.

SW\_SHOWMAXIMIZED Активирует и показывает окно в развернутом виде.

SW\_SHOWMINIMIZED Активирует и показывает окно в свернутом виде.

SW\_SHOWMINNOACTIVE Отображает окно в свернутом виде. Активное окно
остается активным.

SW\_SHOWNA Отображает окно в текущем состоянии. Активное окно остается
активным.

SW\_SHOWNORMAL Активирует и показывает окно. Если окно свернуто или
развернуто,

Windows восстанавливает его к первоначальному размеру и позиции.

Приложение должно определить этот флаг при показе окна в первый раз.

    Значение, которое возвращает ShellExecute такое же, как и у WinExec.
Функцию ShellExecute можно использовать,

например, для открытия корневого каталога диска С:

ShellExecute(hWnd, \'open\', \'c:\\\', nil, nil, SW\_SHOWNORMAL);

    Вы можете заменить строку \"open\" на \"explore\" и в качестве
третьего параметра указать любой каталог,

в этом случае указанная вами папка откроется в Проводнике (Explorer).

    Так же существует системный вызов ShellExecuteEx, который фактически
является полным аналогом

ShellExecute, однако в качестве аргумента он принимает указатель на
структуру, поля которой во многом

совпадают с аргументами ShellExecute. Кроме этого после завершения своей
работы ShellExecuteEx помещает

в одно из полей этой структуры дескриптор запущенной программы.

    Применение этих вызовов довольно просто. Пример программы
использующей WinExec и ShellExecute

приведен в листинге 1.

Листинг 1.

    uses ShellAPI;
    …
    var
      h: hwnd;
    begin
    // Используем ShellExecute
      if ShellExecute(h, 'open', 'readme.txt', nil, nil, SW_SHOW) < 32 then
        begin
          ShowMessage('Немогу выполнить ShellExecute !')
        end;
    // Используем WinExec
      if WinExec('Notepad c:\config.sys', SW_SHOW) < 32 then
        begin
          ShowMessage('Немогу выполнить WinExec !')
        end;
    end;

Взято с сайта <https://blackman.wp-club.net/>
