---
Title: Файловые потоки
Date: 01.01.2007
---


Файловые потоки
===============

::: {.date}
01.01.2007
:::

Теперь разберем возможности работы потомка TStream - TFileStream -
файловый поток. Этот класс был специально введен для работы с файлами.
Для работы с файловым потоком Вам надо записать в Uses модули classes,
Sysutils (classes - включает в себя собственно определение класса,
Sysutils - некоторые константы необходимые для работы).

Вот пример записи/перезаписи файла:

    Procedure WriteFileUsingStream(s, FileName:string);
    begin
      with TFileStream.create(FileName, fmCreate or fmOpenWrite) do
        try
          write(pointer(s)^,length(s));
        finally
          free;
        end;
    end;
     

Теперь небольшой разбор:

TFileStream.create - конструктор класса, его вызов требует указания
имени файла и опций его открытия, следующие опции определены:

    fmCreate         = $FFFF;
    fmOpenRead       = $0000;
    fmOpenWrite      = $0001;
    fmOpenReadWrite  = $0002;
    fmShareCompat    = $0000;
    fmShareExclusive = $0010;
    fmShareDenyWrite = $0020;
    fmShareDenyRead  = $0030;
    fmShareDenyNone  = $0040;

Теперь метод Write - этим методом в файл пишется любая информация из
буфера любого типа, Вам надо указать только буфер и количество
записываемых байтов. В данном случае используется переменная типа String
в качестве буффера, но так как для длинных строк она представляет собой
лишь указатель, то конструкция "pointer(s)^" заставляет обращаться
именно к ее содержимому.

А вот этот код демонстрирует чтение файла с использованием файлового
потока:

    var p:PChar;
    begin
      GetMem(p, 255);
      with TFileStream.create('c:\myText.txt', fmOpenReadWrite) do
        try
          Seek(10,soFromBeginning);
          read(p^, 254);
        finally
          free;
        end;
      showmessage(p);
      FreeMem(p);
    end;
     

И пояснения к коду:

1. Никаких проверок длину файла и его наличие здесь не делается - это
демонстрационный код, а не готовая процедура чтения.

2. Файл мы считываем в буфер типа PChar (с тем же успехом можно
использовать массив или любой другой контейнер). Для тех кто не помнит -
процедуры GetMem(p, 255) и FreeMem(p) - распределение памяти для строки
и освобождение памяти.

3. Метод потока Seek позволяет установить текущую позицию
считывания/записи файла. Первый параметер - номер байта, второй - это от
чего считать этот байт (у нас считать от начала файла), возможны
варианты:
    - soFromBeginning - от начала файла
    - soFromCurrent - от текущей позиции считывания
    - soFromEnd - от конца файла (в этом случае номер байта должен быть
      отрицательным или равным нулю)

4. Собственно считывание из потока осуществляется методом read, в
котором указывается в качестве параметров буфер в который мы читаем и
желаемое количество байт для чтения. Метод read является функцией,
которая возвращает количество байт реально прочитанных из потока.

Заканчивая о файловых потоках хочу упомянуть о методе
CopyFrom который позволяет перекачивать информацию из одного потока в
другой и о свойствах:

Size - размер файла

Position - текущая позиция чтения/записи потока

Работа с файловыми потоками весьма быстра, этот класс, являсь классом
VCL, в то же время базируется на низкоуровневых функциях Windows, что
обеспечивает очень высокую скорость работы и стабильность операций. К
тому же многие компоненты и классы VCL поддерживаю прямое чтение и
запись с файловыми потоками, что занчительно упрощает работу - например
TStringList, TBlobField, TMemoField и другие.

Файловые потоки могут быть рекомендованы к использованию в большинстве
случаев для чтения и записи файлов (за исключением специфических
ситуаций, требующих каких-то других подходов), другими словами если вам
надо просто записать или считать файл, используйте файловые потоки.
