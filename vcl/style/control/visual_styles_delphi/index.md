---
Title: Визуальные стили в Delphi
Date: 01.01.2007
---


Визуальные стили в Delphi
=========================

::: {.date}
01.01.2007
:::

TActionManager является своего рода \"командным пунктом\", из которого
должны управляться элементы управления приложения. Нас интересует только
одно свойство этого компонента

    property Style: TActionBarStyle; 

По умолчанию среда разработки Delphi предлагает к использованию два
стиля:

standard --- приложение использует системную библиотеку ComCtl32.dll
версии 5; 

windows XP --- приложение использует системную библиотеку ComCtl32.dll

версии 6 и единственный стандартный визуальный стиль Windows XP.

Эти стили применимы только к элементам управления, размещенным на
панелях инструментов (TActionToolBar), созданных в компоненте

TActionManager.

Однако не торопитесь возмущаться явной ограниченностью выбора. Вы можете
создать собственный стиль самостоятельно. Правда, это потребует очень
много усилий --- ведь на основе базовых классов элементов управления вам
потребуется создать собственные классы с нужным вам поведением и внешним
видом.

Для этого необходимо создать класс нового визуального стиля на основе
класса TActionBarstyieEx. Затем новый стиль регистрируется при помощи
процедуры

     procedure RegisterActnBarStyle(AStyle: TActionBarStyleEx); 

После этого ваш стиль становится доступным для свойства style компонента
TActionManager. Чтобы отменить стиль, используйте процедуру

    procedure UnRegisterActnBarStyle(AStyle: TActionBarStyleEx); 

Например, обе эти операции удобно выполнить при инициализации и
деинициализации модуля, описывающего класс стиля:

Вариант регистрации и отмены собственного визуального стиля 

    var MyStyle: TMyStyleActionBars; 
    ... 
    initialization 
      MyStyle := TMyStyleActionBars.Create; 
      RegisterActnBarStyle(MyStyle); 
    finalization 
      UnregisterActnBarStyle(MyStyle); 
      MyStyle.Free; 
    end. 

Для смены стиля приложения можно использовать глобальную переменную
нового стиля (см. листинг 6.3). Ее достаточно присвоить свойству style:

    ActionManagerl.Style := MyStyle; 

При смене стиля все элементы управления, расположенные на панелях
компонента ActionManagerl, будут уничтожены и созданы заново с
использованием настроек нового стиля.

Класс TActionBarstyieEx имеет всего несколько методов, которые
необходимо перекрыть при создании собственного стиля. Все они возвращают
классы объектов, используемых при создании пользовательского интерфейса.
Рассмотрим их.

Функция

    function GetStyleName: string; 

возвращает имя стиля. 

Функция

    function GetColorMapClass(ActionBar: TCustomActionBar): TCustomColorMapClass;

позволяет получить ссылку на класс компонента настройки цветовой палитры
(см. разд. \"Компоненты настройки цветовой палитры\" далее в этой
главе), используемый панелью инструментов.

Следующие три метода дают информацию о классах различных типов элементов
управления, используемых при проектировании пользовательского интерфейса
с помощью компонента TActionManager.

Для того чтобы получить доступ к элементам управления, связанным со
стилем, предназначен метод

    function GetControlClass(ActionBar: TCustomActionBar; AnItem:  
    TActionClientltem): TCustomActionControlClass; 

Он возвращает класс элемента управления из панели ActionBar, связанного
с элементом управления Anitem. Именно эта функция вызывается при
создании элементов управления в панелях инструментов компонента 

TAct ionManager.

Как уже говорилось выше, при присвоении свойству style компонента
TActionManager нового значения (экземпляра класса разработанного вами
визуального стиля) уничтожаются все существующие элементы управления и
затем создаются новые. И в процессе создания каждого визуального
компонента вызывается функция Getcontrolciass нового стиля, а
возвращенное ею значение используется для вызова конструктора
соответствующего класса.

Аналогично, для получения класса, используемого в панели меню,
применяется метод

    function GetPopupClass(ActionBar: TCustorrActionBar) : TGetPopupClass; 

и для классов кнопок панели инструментов применяется функция

    function GetScrollBtnClass: TCustomToolScrollBtnClass; 

А класс самой панели инструментов возвращает функция

    function GetAddRemoveltemClass(ActionBar: TCustomActionBar): TCustomAddRemoveltemClass;

Итак, после разработки и отладки собственных классов элементов
управления с заданными свойствами вам потребуется создать потомка от
класса TActionBarstyieEx и перекрыть все перечисленные выше функции так,
чтобы они возвращали нужные классы для используемых типов элементов
управления.
