---
Title: Какие есть директивы компилятора?
Author: Cashey
Date: 01.01.2007
---


Какие есть директивы компилятора?
=================================

::: {.date}
01.01.2007
:::

**{$I+}** и **{$I-}** - директивы контроля ввода/вывода

**{$M}** и **{$S}** - директивы, определяющие размер стека

**{$M+}** и **{$M-}** - директивы информации времени выполнения о типах

**{$Q+}** и **{$Q-}** - директивы проверки переполнения целочисленных операций

**{$R}** - директива связывания ресурсов

**{$R+}** и **{$R-}** - директивы проверки диапазона

**{$APPTYPE CONSOLE}** - директива создания консольного приложения

1) Директивы компилятора, разрешающие или запрещающие проверку утверждений.

По умолчанию **{$C+}** или **{$ASSERTIONS ON}**

Область действия локальная

Директивы компилятора **{$C}** разрешают или запрещают проверку утверждений.
Они влияют на работу процедуры **Assert**, используемой при отладке программ.

По умолчанию действует директива **{$C+}** и процедура **Assert** генерирует
исключение *EAssertionFailed*, если проверяемое утверждение ложно.

Так как эти проверки используются только в процессе отладки программы,
то перед ее окончательной компиляцией следует указать директиву **{$C-}**.
При этом работа процедур **Assert** будет блокирована
и генерация исключений *EassertionFailed* производиться не будет.

Директивы действуют на весь файл исходного кода независимо от того,
в каком месте файла они расположены.

2) Директивы компилятора, включающие и выключающие контроль файлового ввода-вывода.

По умолчанию **{$I+}** или **{$IOCHECKS ON}**

Область действия локальная

Директивы компилятора **{$I}** включают или выключают автоматический контроль
результата вызова процедур ввода-вывода Object Pascal.
Если действует директива **{$I+}**, то при возвращении процедурой
ввода-вывода ненулевого значения генерируется исключение *EInOutError*
и в его свойство *errorcode* заносится код ошибки. Таким образом, при
действующей директиве **{$I+}** операции
ввода-вывода располагаются в блоке *try... except*, имеющем обработчик
исключения EInOutError. Если такого блока нет, то обработка производится
методом **TApplication.HandleException**.

Если действует директива **{$I-}**, то исключение
не генерируется. В этом случае проверить, была ли ошибка, или ее не
было, можно, обратившись к функции **IOResult**. Эта функция очищает ошибку
и возвращает ее код, который затем можно анализировать.  Типичное
применение директивы **{$I-}** и функции **IOResult**
демонстрирует следующий пример:

    {$I-}
     
    AssignFile(F,s);
    Rewrite(F);
     
    {$I+}
    i:=IOResult;
    if i<>0 then 
      case i of
        2: ..........
        3: ..........
      end;

В этом примере на время открытия файла отключается проверка ошибок ввода
вывода, затем она опять включается, переменной i присваивается значение,
возвращаемое функцией **IOResult** и, если это значение не равно нулю (есть
ошибка), то предпринимаются какие-то действия в зависимости от кода
ошибки. Подобный стиль программирования был типичен до введения в Object
Pascal механизма обработки исключений. Однако сейчас, по-видимому,
подобный стиль устарел и применение директив **{$I}** потеряло былое
значение.

3) Директивы компилятора, определяющие размер стека

По умолчанию **{$M 16384,1048576}**

Область действия глобальная

Локальные переменные в процедурах и функциях размещаются в стеке
приложения. При каждом вызове процедуры или функции ее локальные
переменные помещаются в стек. При выходе из процедуры или функции эти
локальные процедуры удаляются из стека.

Директивы компилятора **{$M}** задают параметры стека приложения: его
минимальный и максимальный размеры. Приложение всегда гарантировано
имеет размер стека, равный его минимальной величине. Если при запуске
приложения Windows обнаруживает, что не может выделить этот  минимальный
объем памяти, то выдается сообщение об этой ошибке.

Если во время работы выясняется, что минимального размера стека не
хватает, то размер увеличивается на 4 K, но не более, чем до
установленного директивой максимального размера. Если увеличение размера
стека невозможно из-за нехватки памяти или из-за достижения его
максимальной величины, генерируется исключение *EStackOverflow*.
Минимальный размер стека по умолчанию равен 16384 (16K). Этот размер
может изменяться параметром minstacksize директивы
**{$M}** или параметром number директивы **{$MINSTACKSIZE}**.

Максимальный размер стека по умолчанию равен 1,048,576 (1M).
Этот размер может изменяться параметром maxstacksize директивы **{$M}**
или параметром number директивы **{$MAXSTACKSIZE number}**.
Значение минимального размера стека может задаваться целым числом
в диапазоне между 1024 и 2147483647.
Значение максимального размера стека должно быть не менее
минимального размера и не более 2147483647.
Директивы задания размера стека могут включаться только в программу
и не должны использоваться в библиотеках и модулях.

В Delphi 1 имеется процедура компилятора **{$S}**,
осуществляющая переключение контроля переполнения стека. Теперь этот
процесс полностью автоматизирован и директива **{$S}** оставлена только для обратной
совместимости.

4) Директивы компилятора, включающие и выключающие генерацию информации
времени выполнения о типах (runtime type information - RTTI).

По умолчанию **{$M-}** или **{$ TYPEINFO OFF}**

Область действия локальная

Директивы компилятора **{$M}** включают или выключают генерацию информации
времени выполнения о типах (runtime type information - RTTI). Если класс
объявляется в состоянии **{$M+}** или является
производным от класса объявленного в этом состоянии, то компилятор
генерирует RTTI о его полях, методах и свойствах, объявленных в разделе *published*.
В противном случае раздел published в классе не допускается.
Класс *TPersistent*, являющийся предшественником большинства классов
Delphi и все классов компонентов, объявлен в модуле *Classes* в состоянии
**{$M+}**. Так что для всех классов, производных от
него, заботиться о директиве **{$M+}** не приходится.

5) Директивы компилятора, включающие и выключающие проверку переполнения
при целочисленных операциях

По умолчанию **{$Q-}** или **{$OVERFLOWCHECKS OFF}**

Область действия локальная

Директивы компилятора **{$Q}** включают или выключают проверку переполнения
при целочисленных операциях. Под переполнением понимается получение
результата, который не может сохраняться в регистре компьютера. При
включенной директиве **{$Q+}** проверяется
переполнение при целочисленных операциях _+, -, *, Abs, Sqr, Succ, Pred, Inc_
и _Dec_. После каждой из этих операций размещается код, осуществляющий
соответствующую проверку.  Если обнаружено переполнение, то генерируется
исключение _EIntOverflow_. Если это исключение не может быть обработано,
выполнение программы завершается.

Директивы **{$Q}** проверяют только результат арифметических операций. Обычно
они используются совместно с директивами **{$R}**, 
проверяющими диапазон значений при присваивании.

Директива **{$Q+}** замедляет выполнение программы
и увеличивает ее размер. Поэтому обычно она используется только во время
отладки программы. Однако, надо отдавать себе отчет, что отключение этой
директивы приведет к появлению ошибочных  результатов расчета в случаях,
если переполнение действительно произойдет во время выполнении
программы. Причем  сообщений о подобных ошибках не будет.

6) Директивы компилятора, включающие и выключающие проверку диапазона
целочисленных значений и индексов

По умолчанию **{$R}** или **{$RANGECHECKS OFF}**

Область действия локальная

Директивы компилятора **{$R}** включают или выключают проверку диапазона
целочисленных значений и индексов. Если включена директива
**{$R+}**, то все индексы массивов и строк и все
присваивания скалярным переменным и переменным с ограниченным диапазоном
значений проверяются на соответствие значения допустимому диапазону.
Если требования диапазона нарушены или присваиваемое значение слишком
велико, генерируется исключение _ERangeError_. Если оно не  может быть
перехвачено, выполнение программы завершается.

Проверка диапазона длинных строк типа _Long strings_ не производится.

Директива **{$R+}** замедляет работу приложения и
увеличивает его размер. Поэтому она обычно используется только во время
отладки.

7) Директива компилятора, связывающая с выполняемым модулем файлы ресурсов

Область действия локальная

Директива компилятора **{$R}** указывает файлы
ресурсов (.DFM, .RES), которые должны быть включены в выполняемый модуль
или в библиотеку. Указанный файл должен быть файлом ресурсов Windows. По
умолчанию расширение файлов ресурсов - .RES.

В процессе компоновки компилированной программы или библиотеки файлы,
указанные в директивах **{$R}**, копируются в
выполняемый модуль. Компоновщик Delphi ищет эти файлы сначала в том
каталоге, в котором расположен модуль, содержащий директиву
**{$R}**, а затем в каталогах, указанных при
выполнении команды главного меню **Project | Options** на странице
_Directories/Conditionals_ диалогового окна в опции _Search path_
или в опции _/R_ командной строки DCC32.

При генерации кода модуля, содержащего форму, Delphi автоматически
включает в файл _.pas_ директиву **{$R *.DFM}**,
обеспечивающую компоновку файлов ресурсов форм. Эту директиву нельзя
удалять из текста модуля, так как в противном случае загрузочный модуль
не будет создан и генерируется исключение _EResNotFound_.

Автор: Cashey

Взято с Vingrad.ru <https://forum.vingrad.ru>

Исправлено и дополнено: Jin X

Примечание: Vit

Все установленные в настройках опции компиляции можно вставить
непосредственно в текст программы нажав клавиши _Ctrl-O, O_
