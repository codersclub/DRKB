---
Title: Ловим баги или почему программы допускают недопустимые операции
Date: 01.01.2007
---


Ловим баги или почему программы допускают недопустимые операции
===============================================================

::: {.date}
01.01.2007
:::

Ошибки - неизбежное зло программирования. Видимо пока трудно даже
представить средство с помощью которого можно избавится от них.
Человеку, которые выдумает это чудодейственное лекарство, благодарные
потомки-программисты, несомненно, воздвигнут памятник. Пока же остается
лишь заниматься обычным делом: ловлей багов.

"Нарушение Доступа" - фраза, которую пользователи видят, когда
приложение делает попытки обратиться к памяти, которая не обозначена для
их использования - и как следствие происходит сбой в работе программы:

Access violation at address \<HEX\_value\>

in module \<Application.Exe\>.

Read of address \<HEX\_value\_2\>

Ситуация при которой Windows давала бы полную свободу программам -
записывай данные куда хочешь, скорее всего бы привела к разноголосице
программ и полной потери управления над компьютером. Но этого не
происходит - Windows стоит на страже "границ памяти" и отслеживает
недопустимые операции. Если сама она справиться с ними не в силах -
происходит запуск утилиты Dr. Watson, которая записывает данные о
возникшей ошибки, а сама программа закрывается.

Известно что, при программирование, особенно крупных программных
продуктов, уследить за всеми процессами в коде невозможно, да и нет
необходимости. Использование сторонних компонентов и библиотек только
усложняет дело. Именно поэтому программисты Delphi, порой и сталкиваются
со "своенравными" программами, которые то и дело норовят "сбросить
пользователя". Итак, давайте рассмотрим некоторые вопросы, связанные с
корректной средой программирования, так и непосредственно проблем
написания кода, которые ведут к возникновению ошибок типа "ошибка
доступа" (AVS) и очертим наиболее известные пути их исправления.

Мы можем поделить AVS, с которыми сталкиваются при разработке в Delphi
на два основных типах: ошибки при выполнения и некорректная разработка
проекта, что вызывает ошибки при работе программы.

Ошибки возникают при старте и закрытии Delphi или формировании проекта.
Причиной могут являться сбои в "железе" компьютера.

Эти ошибки могут быть вызваны различными источниками, включая систему
BIOS, операционную систему или аппаратные подпрограммы драйверов.
Некоторые видео-, звуковые или сетевые платы могут фактически вызывать
подобного рода ошибки в Delphi. Для решения подобных аппаратных проблем
можно предпринять последовательность неких "стандартных" ходов:

Проверить, что не имеется никаких конфликтов между установленными
устройствами, устранить обнаруженные конфликты;

Попробовать слегка уменьшить "аппетиты" видеодрайвера - поставить
меньшее разрешение;

В случае если у вас двухпроцесорная система обеспечить равное изменение
шага для каждого процессора;

И в конце концов просто попытаться заменить драйвера на более свежие.

Но помимо чисто железных проблем - большую головную боль могут вызвать
ошибки в работе программного обеспечения. Особенно это касается
непосредственно операционной системы. Зачастую Windows терпит крах
спонтанно. Вот рекомендации которые помогут вам создать более устойчивую
среду программирования:

Хотя Windows 9X популярная система, разработку лучше проводить в Windows
NT или Windows 2000 - это более устойчивые операционные системы.
Естественно при переходе на них придется отказаться от некоторых благ
семейства Windows 95/98/Me - в частности не все программы адоптированы
для Windows NT/2000. Зато вы получите более надежную и стабильную
систему.

Не забывайте о том, как важно всегда иметь под рукой свежие версии
компонентов для Delphi и дополнительных библиотек. В отличие от Windows
создатели данных пакетов стараются от версии к версии уменьшать
количество ошибок.

Следите за тем, что бы устанавливаемые компоненты были предназначены
непосредственно для вашей версии Delphi. Попробуйте деинсталлировать
чужеродные компоненты один за другим (или пакет за пакетом) пока
проблема не будет устранена.

Контролируйте все программные продукты установленные на вашей машине и
деинсталлируйте те из них, которые сбоят. Фаворитами AV среди них
являются шароварные утилиты и программы и бета версии программных
продуктов.

Все вышеперечисленное в основном не касалось самого процесса
программирования и в малой степени зависит от разработчика. Теперь же
обратимся к теме, как не допустить при разработки программного продукта
ситуации при которой, он сам будет являться причиной ошибки.

Вы могли бы рассмотреть компилирование вашего приложения с директивой
{$D}, данная директива компилятора может создавать файлы карты (файлы с
расширением map, которые можно найти в том же каталоге, что и файлы
проекта), которые могут послужить большой справкой в локализации
источника подобных ошибок. Для лучшего "контроля" за своим
приложением, компилируйте его с директивой {$D}. Таким образом, вы
заставите Delphi генерировать информацию для отладки, которая может
послужить подспорьем при выявление возникающих ошибок.

Следующая позиция в Project Options - Linker & Compiler позволяет вам,
определить все для последующей отладки. Лучше всего, если помимо самого
выполняемого кода будет доступна и отладочная информация - это поможет
при поиске ошибок. Отладочная информация увеличивает размер файла и
занимает дополнительную память при компилировании программ, но
непосредственно на размер или быстродействие выполняемой программы не
влияет. Включение опций отладочной информации и файла карты дают
детальную информацию только, если вы компилируете программу с директивой
{$D+}.

Эта информация состоит из таблицы номеров строк для каждой процедуры,
которая отображает адреса объектных кодов в номера строк исходного
текста. Директива $D обычно используется совместно с другой директивой
- $L, что позволяет или запрещает генерацию информации о локальных
символах для отладки.

Таким образом вы без труда сможете найти точный адрес той подпрограммы,
которая была ответственна за ошибку. Одна из наиболее общих причин
ошибок выполнения - использование объекта, который еще не был создан.
Если второй адрес при выдачи ошибки - FFFFFFF (или 0000000) Вы можете
почти утверждать, что было обращение к объекту, который еще не был
создан. Например, вызов метода формы, которая не была создана.

    procedure TfrMain.OnCreate(Sender: TObject);
    var
      BadForm: TBadForm;
    begin
      BadForm.Refresh; // причина ошибки
    end;

Попытаемся разобратся в этой ситуации. Предположим, что BadForm есть в
списке "Available forms " в окне Project Options\|Forms. В этом списке
находятся формы, которые должны быть созданы и уничтожены вручную. В
коде выше происходит вызов метода Refresh формы BadForm, что вызывает
нарушение доступа, так как форма еще не была создана, т.е. для объекта
формы не было выделено памяти.

Если вы установите "Stop on Delphi Exceptions " в Language Exceptions
tab в окне Debugger Options, возможно возникновение сообщения об ошибке,
которое покажет, что произошло ошибка типа EACCESSVIOLATION.
EACCESSVIOLATION - класс исключение для недопустимых ошибок доступа к
памяти. Вы будете видеть это сообщение при разработке вашего приложения,
т.е. при работе приложения, которое было запущено из среды Delphi.

Следующее окно сообщения будет видеть пользователь - и программа будет
закрыта при совершение недопустимой операции:

Access violation at address 0043F193

in module \'Project1.exe\'

Read of address 000000.

Первое шестнадцатиричное число (\'0043F193\') - адрес ошибки во время
выполнения программы. Выберите, опцию меню \'Search\|Find Error\',
введите адрес, в котором произошла ошибка (\'0043F193\') в диалоге и
нажмите OK. Теперь Delphi перетранслирует ваш проект и покажет вам,
строку исходного текста, где произошла ошибка во время выполнения
программы, то есть BadForm.Refresh.

Естественно, что списка наиболее общих причин ошибок, вызывающих
аварийное завершение работы программы, написанной в Delphi в чистом виде
нет. Есть несколько общих "узких мест" в коде и структуре программы,
когда подобная ошибка может произойти. Перечислим наиболее
распространенные.

Недопустимый параметр API

Если вы пытаетесь передать недопустимый параметр в процедуру Win API,
может произойти ошибка. Необходимо отслеживать все нововведения в API
при выходе новых версий операционных систем и их обновлений.

Уничтожение исключения

Никогда не уничтожайте временный объект исключения. Обработка исключения
автоматически уничтожает объект исключения. Если вы уничтожите объект
самостоятельно, то приложение попытается уничтожать объект снова, и
произойдет ошибка.

    Zero := 0;
    try
      dummy := 10 / Zero;
    except
      on E: EZeroDivide do
        MessageDlg('Can not divide by zero!', mtError, [mbOK], 0);
      E.free. // причина ошибки
    end;

Индексация пустой строки

Пустая строка не имеет никаких достоверных данных. Следовательно,
попытка индексировать пустую строку - подобно попытке обратиться к нулю,
что приведет также к ошибке:

     
    var
      s: string;
    begin
      s := '';
      s[1] := 'a'; // причина ошибки
    end;

Обращение к динамической переменной

Вы должны строить обращение к динамической переменной корректно, иначе
вы перемещаете адреса указателей и возможно разрушаете другие выделенные
ячейки памяти.

    procedure TForm1.Button1Click(Sender: TObject);
    var
      p1, p2: pointer;
    begin
      GetMem(p1, 128);
      GetMem(p2, 128);
      {эта строка может быть причиной ошибки}
      Move(p1, p2, 128);
      {данная строка корректна }
      Move(p1^, p2^, 128);
      FreeMem(p1, 128);
      FreeMem(p2, 128);
    end;

Перечисленные подходы позволят избежать наиболее частых недочетов в
разработке, которые могут вызвать столь неприятное как для пользователя,
так и для разработчика сообщение о том, что программа выполнила
"недопустимую операцию".

Взято с <https://delphiworld.narod.ru>
