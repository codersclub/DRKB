---
Source: Королевство Дельфи <http://www.delphikingdom.com/>
Date: 08.04.2002
Title: DirectX для начинающих — Sprite
Author: Виктор Кода
---

DirectX для начинающих — Sprite
=====================================

Этот пример демонстрирует вывод изображения средствами DirectDraw.
Он построен без использования VCL, но я надеюсь это не помешает вам. Вот файлы проекта:

- sprite.dpr - отвечает за создание окна и выборку системных сообщений.
- basedd8.pas - содержит функции для работы с DirectDraw.

После регистрации класса окна и его отображения производится инициализация DirectDraw.
За это отвечает функция InitDirectDraw().
Рассмотрим её работу подробнее.

Первым делом необходимо создать объект DirectDraw.
На сегодняшний момент его нужно создавать функцией DirectDrawCreateEx(),
а не DirectDrawCreate(), как это было в прошлых версиях.

Первый параметр представляет собой указатель на уникальный идентификатор драйвера видеоадаптера,
но т. к. в большинстве случаев компьютеры оснащаются одним видеоадаптером,
то можно передать nil.

Второй параметр является указателем на интерфейс IDirectDraw7. 

Параметр `iid` может принимать только одно значение - `IID_IDIRECTDRAW7`.
Любое другое значение приведёт к ошибке `DDERR_INVALPARAMS`.

Последний параметр в описываемой функции на данный момент не используется
и предназначен для будущих версий.

Результат, возвращаемый функцией (равно как и любой другой в DirectX), имеет тип HRESULT,
т.е. может иметь множество кодов завершения.
В DirectDraw успешная работа функции определяется константой `DD_OK`,
а ошибочная - множеством других, зависящих от типа ошибки.
Кроме упоминавшейся константы `DDERR_INVALPARAMS` функция может вернуть `DDERR_UNSUPPORTED`,
сообщив тем самым, что объект DirectDraw не инициализирован.

Чтобы избежать мороки с проверкой возвращённого результата,
рекомендуется применять макросы (в Delphi практически функции) `FAILED()` и `SUCCEEDED()`,
определённые в windows.pas.
Дело в том, что 31-й бит возвращаемого значения содержит флаг критичности,
который указывает, произошла ли ошибка или нет.
Если бит равен 0, то ошибки не было, а если он равен 1, то ошибка имела место.
Это как раз и проверяют вышеуказанные макросы.

Конечно, никто не запрещает написать так:

```
If DirectDrawCreateEx( nil, lpDD7, IID_IDIRECTDRAW7, nil ) <> DD_OK then...
```

Но профессионалы используют исключительно макросы `FAILED()` и `SUCCEEDED()`.

После создания объекта необходимо установить режим кооперации - т. е. определить,
оконный или полноэкранный режим будет использовать DirectDraw.
Надо сразу "брать быка за рога" и программировать полноэкранные приложения.
Режим кооперации учтанавливается методом `IDirectDraw7.SetCooperativeLevel()`.

Первым параметром передаётся идентификатор окна типа HWND.

Второй представляет собой комбинацию флагов. Установим такие:

- `DDSCL_ALLOWREBOOT` - указывает, что будет доступно окно снятия программы по нажатию клавиш Ctrl-Alt-Del.
   Полезно при отладке приложения (вдруг зависнет). Этот флаг впоследствии можно и убрать.
- `DDSCL_EXCLUSIVE` - используется только в полноэкранных приложениях.
- `DDSCL_FULLSCREEN` - устанавливает полноэкранный режим. При его ипользовании обязателен флаг `DDSCL_EXCLUSIVE`.

Следующим действием является установка видеорежима.
Это делает метод `IDirectDraw7.SetDisplayMode()`.

Первые три параметра указывают ширину и высоту экрана,
а также глубину палитры (8, 16, 24, 32).

Последние два параметра используются редко.
Подробности о них можно узнать из SDK.

Итак, мы создали объект DirectDraw и изменили разрешение экрана.
В этот момент работы программы наше окно моментально заслоняет все объекты на Рабочем столе,
включая панель задач.
Если вы ещё не обратили внимание, для создания окна я использовал структуру WNDCLASSEX,
а не WNDCALSS.
Дело в том, что окно, построенное на базе последней, не сразу закрывает весь экран - 1-1,5 секунды
продолжает красоваться "Панель задач".
Возможно, всё дело во флаге `WS_EX_TOPMOST,` который можно использовать только совместно с WNDCLASSEX.

Не стоит пренебрегать данными преимуществами - зто делает программу более "профессиональной"
при минимуме усилий.
Попробуйте создавать окно на базе разных классов - сами почувствуете разницу.

Следующим шагом создадим первичную поверхность.
Фактически это область видеопамяти, которая будет использоваться видеоадаптером
для отображения картинки на экране монитора.

Поскольку поверхности могут быть разных типов (не только первичными, но и внеэкранными),
а метод для их создания только один - `lDirectDraw7.CreateSurface()`,
необходимо каким-то образом указать, что мы хотим создать именно первичную поверхность.
Как это сделать?

Обратите внимание, что первый параметр метода - это указатель на структуру TDDSURFACEDESC2
(кстати, в SDK 8 для С++ этим параметром нужно передавать адрес структуры TDDSURFACEDESC,
а не TDDSURFACEDESC2.
Это ошибка перевода заголовочных файлов C++ на Pascal: тем не менее, всё работает корректно).
Именно через эту структуру DirectDraw узнает, какой тип поверхности нужно создать.

Перед использованием структуры распространённой практикой является заполнение её нулями -
на случай всякого "мусора" в RAM,
который может привести к ошибке во время выполнения.
Я использую функцию ZeroMemory(), но можно и FillChar().

Следующим действием является заполнение поля `dwSize` этой структуры размером самой структуры.
Это действие обязательно!

Поле `dwFlags` определяет, какие другие поля структуры мы будем использовать.
По-видимому, это сделано для обеспечения наивысшего быстродействия - теперь DirectDraw не будет
просматривать все поля структуры (а их очень много), а "заглянет" только в те, которые мы указали.
Мы будем использовать поля `ddsCaps` и dw`BackBufferCount`.
Укажем это флагами `DDSD_CAPS` и `DDSD_BACKBUFFERCOUNT`.
Поле `ddsCaps.dwCaps` как раз и определяет тип создаваемой поверхности -
флаги `DDSCAPS_PRIMARYSURFACE`, `DDSCAPS_FLIP` и `DDSCAPS_COMPLEX` сообщат DirectDraw,
что мы хотим создать первичную комплексную поверхность с возможностью переключения буферов.

Поле `dwBackBufferCount` указывает количество задних буферов,
которые мы подключим к первичной поверхности - установим 1 (хотя можно подключить и больше).

Вызываем метод `lDirectDraw7.CreateSurface()`, указав вторым параметром нужный интерфейс.

Третий параметр заразервирован и не используется.

Теперь к первичной поверхности нужно "приаттачить" задний буфер.
Этот буфер исключительно важен для самого механизма вывода изображений и необходим
для избавления от мерцания спрайтов.
Для создания заднего буфера используется структура TDDSCAPS.
Очищаем её и задаём флаг `DDSCAPS_BACKBUFFER`.

Методом `IDirectDrawSurface.GetAttachedSurface()` подсоединим задний буфер.

Всё, инициализация DirectDraw закончена.

Теперь нужно создать внеэкранные поверхности и загрузить в них изображение.
Внеэкранные поверхности представляют собой линейные области данных в видео- или системной памяти,
которые предназначены для хранения графических данных.
За всё это отвечает процедура LoadFiles().

Первым делом получаем идентификатор загруженного функцией LoadImage() растра.
Я не буду её описывать, т. к. к DirectDraw она не имеет прямого отношения -
за этим прошу в Help Win32 API.
Скажу лишь, почему я применил именно эту функцию.
Дело в том, что часто возникает необходимость загружать не только файлы формата bmp,
но и файлы других форматов, например gif или JPEG.
Обычно для их загрузки применяются различные библиотеки DLL (например, nViewLib.dll),
результаты работы функций в этих библиотеках - величина типа HBITMAP.
Её можно использовать в единообразном методе загрузки файлов различных форматов.
Рекомендую использовать именно такой метод,
если только вы не гуру в алгоритмах сжатия разных форматов файлов
и не собираетесь самостоятельно писать функции по преобразованию сжатых файлов в растр -
ведь DirectDraw подобных решений не предоставляет.

К сожалению, недостаток такого способа в том, что он немного медленнен :-(.
Впрочем,  увеличенное время считывания должно сколь-нибудь существенно проявиться
лишь при загрузке очень большого количества файлов (30-40 МБ и более).

Теперь рассмотрим процедуру CopyImage().

Первым параметром мы передаём адрес интерфейса IDirectDrawSurface - именно на на эту поверхность
и будет загружен растр.

Вторым - идентификатор загруженного растра.
Вообще, работа функции CopyImage() базируется на GDI.
После создания контекста и выбора в него растра мы получаем размеры этого растра функцией GetObject().

Теперь нужно создать поверхность DirectDraw c полученными шириной и высотой растра.
За это отвечает ещё одна функция `CreateSurface()`.
Механизм в ней похож на тот, что использовался для создания первичной поверхности,
поэтому подробно я его описывать не буду.
Обратите только внимание на флаг `DDSCAPS_OFFSCREENPLAIN` - он указывает,
что мы хотим создать именно внеэкранную поверхность.

К сожалению, нельзя динамически менять размер поверхности DirectDraw -
для этого нужно заново создать её и загрузить данные.
После успешного создания поверхности можно загрузить на неё растр -
для этого существует удобный метод `IDirectDrawSurface.GetDC()`.

Захватив контекст устройства, осуществляем копирование растра с одного контекста на другой,
захваченный (а фактически на поверхность DirectDraw).
Для этого используется функция GDI BitBlt().
Достоинством метода можно считать тот факт,
что теперь на поверхности DirectDraw можно рисовать любыми функциями GDI,
а не только BitBlt(), не прибегая к прямому доступу к памяти,
в которой расположена поверхность - например, нарисовать линию или овал.

А если возникнет потребность вывести текст?
Так что отказываться от GDI пока ещё рано.

Да, захваченный контекст нужно освободить методом `IDirectDrawSurface.ReleaseDC()`.

Ну вот, ещё один шаг позади.
Самое время вернуться в модуль .dpr и посмотреть, что происходит дальше.

Приложение начинает осуществлять выборку системных сообщений,
а при отсутствии таковых вызывает функцию OnDraw().
В VCL этот алгоритм называется `Application.OnIdle`.

Рассмотрим OnDraw() подробнее.
Это - сердце алгоритма вывода изображений на экран.

Вывод изображения в полноэкранном режиме осуществляется методом `IDirectDrawSurface.BltFast()`.
Этот метод должен вызываться для поверхности, созданной как задний буфер - именно на нём
мы и будем рисовать.
Этот метод максимально быстр, но ограничен функционально, например,
он не в состоянии сжать по осям выводимое изображение.

Первые два параметра - координаты левого верхнего угла вывода спрайта.

Третий - поверхность, содержимое которой будем выводить.

Четвёртый - адрес структуры типа TRect, которая будет определять облать вывода поверхности -
её инициализацию я сделал перед вызовом метода `IDirectDrawSurface.BltFast()`.

Поэксперементируйте с функцией SetRect() и посмотрите,
как параметры в ней влияют на изменение в выводе графики.

Пятым параметром метода передадим константу `DDBLTFAST_WAIT` -
она нужна для корректного вывода на экран.

Описанные действия нужно повторить для каждого выводимого спрайта.

Последним делом нужно переместить содержимое заднего буфера на первичную поверхность,
содержимое которой, как я уже сказал, представляет собой текущее изображение на мониторе.
Сделаем это методом `IDirectDrawSurface.Flip()`, указав первым параметром `nil` -
ведь у нас только один задний буфер.

Константа `DDFLIP_WAIT` нужна для коректного вывода на экран.
Этот метод следует вызывать только для первичной поверхности.

Перемещение заднего буфера на экран - один из самых быстрых методов DirectDraw.

Теперь изображение появится на экране.
Можете подвигать спрайт при помощи клавиатуры - так интересней.

После нажатия на клавишу Escape происходит выход из цикла.
Затем программа вызывает нижестоящую функцию `ReleaseDirectDraw()`,
которая восстанавливает начальное разрешение и удаляет созданные поверхности и объект DirectDraw.
Заметьте, что вызов `_Release()` для соответствующего интерфейса будет корректным только в том случае,
если произошёл вызов `_AddRef()`.
Вообще, говорят что вызовы эти необязательны,
но я всё же использую их для полной корректности работы программ.

Последним в цепочке действий разрушается окно - действие не обязательное,
но для корректного освобождения памяти желательное.


Далее: [DirectX для начинающих — Direct Sound](./sample03/)
