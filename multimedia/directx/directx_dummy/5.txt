
<h1>
DirectX для начинающих. Часть пятая
</h1>
<hr><br>
<p align="right">
Оформил: <a target="_blank" href="mailto:DeeCo@mail.ru">DeeCo</a><br>
</p>
<p align="right">Автор: <a href="http://www.delphikingdom.com/asp/users.asp?ID=1146"><strong>Виктор Кода</strong></a></p>
В этот раз мой новый урок будет посвящён азам
использования интерфейса Direct3D - наиболее сложного и объёмного из состава
DirectX8 SDK.
<p>Я не собираюсь рассказывать, как построить объёмный кубик или классический
чайник в пространстве, нет. Вместо этого я решал затронуть довольно интересную
тему - как организовать вывод 2D-графики посредством Direct3D. Я решил заняться
этим вопросом, т. к. всё чаще API трёхмерного моделирования используются для
создания плоских изображений. Соответсвенно и я собираюсь перевести свои
программы на новы рельсы. </p>Вообще, интерфейсы IDirectDraw7 и
IDirectDrawSurface7 - последние в составе SDK, которые предназначены для вывода
двумерной графики путём битовых переносов. Эти интерфейсы были введены в DirectX
версии 7 и по сути, уже ничего принципиально нового не содержали. Единственное
отличие состяло в более тесной интеграции DirectDraw с Direct3D, но и это уже в
прошлом. С началом разработки DirectX 8 отдел Microsoft принял решение навсегда
остановить развитие этой компоненты, а Direct3D сделать полностью
самодостаточным и единственным средством вывода графики в DirectX. Теперь он так
и называется - DirectXGraphics. Впрочем, в составе SDK до сих пор присутствует
файл ddraw.h, чтобы пользователи имели возможность и дальше работать с
DirectDraw, и примеры по его использованию. Это как намёк на то, что не следут
на 100% отказываться от старых приёмов работы с графикой.
<p>По-видимому, решение об остановке исходило из невозможности добавить в
DirectDraw ещё сколь-нибудь существенных деталей. Аппаратно эффекты DirectDraw
не поддерживаются и планов таких у производителей видеокарт не намечалось. В
тоже время многие программисты уже начали применять Direct3D для вывода
2D-графики, игнорируя DirectDraw. Взвесив все "за" и "против", было решено
доработать Direct3D как средство построения плоских изображений, а DirectDraw
объявить бесперспективным. Вот так старейший компонент, когда-то служивший в
DirectX единственным средством представления графики, теперь является
анахронизмом... </p>Соответственно, и нам нет смысла долго "сидеть" на нём, а
надо потихоньку перебираться в Direct3D, догонять технологии, так сказать. Но
прежде всего необходимо оговорить ограничения, связанные с использованием этого
интерфейса:
<ol>
<li>Для вывода графики необходимо, чтобы компьютер был оснащён простейшим, но
всё же 3D-ускорителем. И хотя вывод будет осуществляться и на обычной
видеокарте, картинка будет искажена, а скорость вывода будет неприемлемо мала.
Впрочем, в теперешнюю эпоху навороченных акселераторов простейшие их модели
стоят копейки.
</li><li>Текстуры, содержащие изображение, по размерам должны быть кратны степени
двойки. Т. е. 64Х64 или 256Х512 - подходит, а 63х255 - нет. Это вроде как на
руку аппаратной части. </li></ol>А теперь приступим непосредственно к воплощению
замысла на практике. Для этого сперва необходимо подключить два заголовочных
файла, в которых энтузиасты JEDI разместили всё, что необходимо для полноценной
работы с Direct3D версии 8:
<pre><b>uses</b>
directxgraphics,
d3dx8;</pre>
Эти два файла представляют собой объединение многих других файлов
из SDK для C/C++ (их названия приведены в самом начале). Первый файл содержит
описание основных интерфейсов Direct3D, а второй - дополнительных интерфейсов
Direct3DX. Это вспомогательная библиотека, содержащая интерфейсы высокого уровня
и множество функций разного назначения, дополнение к основному комплексу.
Обратите своё внимание на такую строчку из файла d3dx8.pas:
<pre><b>const</b>
d3dx8dll = 'D3DX8ab.dll';</pre>
Это означает, что
все функции экспортируются из указанной динамической библиотеки. Хотя она и
поставляется в архиве с остальными файлами *.pas, но не входит в стандартный
run-time от Microsoft. Т. е. ваши приложения, основанные на Direct3D, не смогут
выполняться на компьютерах других пользователей, если только вы не будете каждый
раз прикреплять к своим файлам нестандартную библиотеку. Откуда её выкопали JEDI
- Бог его знает, однако нестандартный run-time - это плохо. Решением может
служить изменение значения константы:
<pre><b>const</b>
d3dx8dll = 'd3dx8d.dll';</pre>
<p>После такой замены всё работает вроде как нормально, во всяком случае, я не
встретил ещё ни одной ошибки. Файл d3dx8d.dll я нашёл у себя в директории
Windows/System, он входит в стандартный пакет DirectX 8. В любом случае, могу
посоветовать такой приём: компилируйте все свои Direct3D-приложения с
использованием d3dx8ab.dll, а когда возникнет необходимость передать программу
другим пользователям, замените имя библиотеки и перекомпилируйте программу. Если
всё работает нормально, можете смело распространять своё творение. </p>Также
нужно заметить, что размер "пустого" выполняемого файла получается около 40 кб,
а не 17-20. Причина этого кроется в том, что модуль d3dx8.pas подключает модуль
sysutils.pas. Самое "смешное" в том, что с увеличенным размером приходится
мириться из-за вызова единственной функции CompareMem() (из функции
D3DXMatrixEqual()). Если вы такие же щепетильные в этом вопросе, как и я, то
могу посоветовать такое решение: скопируйте функцию CompareMem() из sysutils.pas
в d3dx8.pas, и удалите ссылку на модуль из списка uses. Размер минимальной
программы уменьшится до стандартных для Delphi 17 кб. <br>Разобравшись с
заголовочными файлами, объявим далее необходимые переменные:
<pre><b>var</b>
g_pD3D: IDirect3D8 = <b>nil</b>; <font color="#000080"><i>// общий интерфейс Direct3D</i></font>
g_device: IDirect3DDevice8 = <b>nil</b>; <font color="#000080"><i>// наша видеокарта</i></font>
g_pTexture: IDirect3DTexture8 = <b>nil</b>; <font color="#000080"><i>// текстура</i></font>
g_pSprite: ID3DXSprite = <b>nil</b>; <font color="#000080"><i>// спрайт</i></font></pre>
Теперь необходимо провести инициализацию Direct3D:
<pre><font color="#000080"><i>// проверяем правильность динамической компоновки</i></font>
<b>if</b> @_Direct3DCreate8 = <b>nil</b> <b>then</b>
exit;
<font color="#000080"><i>// получаем интерфейс IDirect3D8</i></font>
g_pD3D := Direct3DCreate8(D3D_SDK_VERSION);
<b>if</b> g_pD3D = <b>nil</b> <b>then</b>
exit;</pre>
<p>Здесь я проверяю адрес функции на корректность, ведь мы производим
динамическую компоновку библиотеки, есть вероятность, что её не окажется на
месте. Если всё в порядке, мы получаем интерфейс IDirect3D8. Это - первый
интерфейс, с которым имеет дело программист. Его основная задача - общая работа
с видеокартой и монитором - "создание" и получение характеристик видеокарты,
перечисление доступных видеорежимов, дескрипторов мониторов и т.д. </p>При
инициализации графического устройства нам обязательно понадобится текущий
видеоформат. Его можно задать самостоятельно, но так как он может не
поддерживаться установленной видеокартой, а проверять это в маленьком примере
накладно, лучше воспользоваться форматом текущего видеорежима:
<pre><font color="#000080"><i>// получаем формат текущего видеорежима</i></font>
<b>if</b> FAILED(g_pD3D.GetAdapterDisplayMode(D3DADAPTER_DEFAULT, d3ddm)) <b>then</b>
exit;</pre>
После этого необходимо заполнить поля структуры
TD3DPRESENT_PARAMETERS:
<pre><font color="#000080"><i>// подготавливаем структуру TD3DPRESENT_PARAMETERS</i></font>
ZeroMemory(@d3dpp, sizeof(d3dpp));
d3dpp.Windowed := BOOL(FALSE); <font color="#000080"><i>// полноэкранный режим</i></font>
d3dpp.BackBufferWidth := SCREEN_WIDTH; <font color="#000080"><i>// высота и</i></font>
d3dpp.BackBufferHeight := SCREEN_HEIGHT; <font color="#000080"><i>// ширина заднего буфера</i></font>
d3dpp.BackBufferFormat := d3ddm.Format;
<font color="#000080"><i>// формат буфера - как и у текущего экрана</i></font>
d3dpp.SwapEffect := D3DSWAPEFFECT_DISCARD;
<font color="#000080"><i>// тип сброса содержимого буфера в окно</i></font></pre>
<p>Замечу, что поле Windowed поределяет, будем ли мы работать в оконном или
полноэкранном режиме. Замените FALSE на TRUE, и получите вывод в окно.
</p>Теперь необходимо инициализировать графическое устройство:
<pre><font color="#000080"><i>// создаём устройство Direct3D</i></font>
<b>if</b> FAILED(g_pD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,
D3DCREATE_SOFTWARE_VERTEXPROCESSING, d3dpp,
g_device)) <b>then</b>
<b>begin</b>
exit;
<b>end</b>;</pre>
Создаваемое устройство может быть различных типов. Поясню
только самое общее.
<dl>
<dt>D3DDEVTYPE_HAL
</dt><dd>- это аппаратное устройство, где все операции выполняются графическим
процессором видеокарты. Как раз это нам и нужно.
</dd><dt>D3DDEVTYPE_REF
</dt><dd>- программное устройство, все операции выполняет центральный процессор.
Крайне медленно, зато можно использовать любые возможности Direct3D, вроде
пиксельных и вертексных шейдероов. В основном этот параметр нужен для
производителей видеокарт, чтобы они подгоняли результат аппаратного рендеринга
к эталонному программному.
</dd><dt>D3DCREATE_SOFTWARE_PROCESSING
</dt><dd>- обработка вершин производится ЦП. Не очень быстро, так что в серьёзных
программах лучше использовать другие флаги (их можно легко узнать из
заголовочного файла), но для простоты я выбрал этот. Кстати, некоторые
видеокарты могут работать только с указанием этого флага. </dd></dl>
<p>Полученный интерфейс IDirect3Ddevice8 представляет собой как бы абстракцию
над видеокартой. Вызывая те или иные методы, мы отдаём команды графическому
процессору. Именно этот интерфейс является основным в работе по построению
изображений. </p>Для простоты здесь же созданим и объект, который будет служить
спрайтом:
<pre>result := SUCCEEDED(D3DXCreateSprite(g_device, g_pSprite));</pre>
<p>Интерфейс ID3DXSprite как раз и служит для вывода простых спрайтов в
Direct3D. Использовать его очень легко, т. к. этот интерфейс - просто надстройка
над более низкоуровневымы операциями Direct3D. Я пробовал рисовать и вторым
способом, но он более объёмен и сложен, так что для примера я выбрал первый. Как
и всякое простое решение, он не позволит сделать всего, что может API. Если вам
со временем станет чего-то не хватать, можно прибегнуть к явному
программированию. </p>После инициализации Direct3D следующим шагом является
загрузка текстуры:
<pre>hr := D3DXCreatewTextureFromFileEx(g_device, pchar(strFileName), 0, 0,
D3DX_DEFAULT, 0, D3DFMT_UNKNOWN,
D3DFMT_UNKNOWN, D3DPOOL_DEFAULT,
D3DXFILTER_NONE, D3DXFILTER_NONE,
D3DCOLOR_XRGB(0, 255, 0), <b>nil</b>, <b>nil</b>,
g_pTexture);</pre>
Функция D3DXCreateTextureFromFileEx() является частью комплекса Direct3DX,
и позволяет нам загружать текстуры из файлов разного формата. Результатом
является корректный указатель на интерфейс IDirect3Dtexture8. Существует более
простая реализация функции (без приставки Ex), но она не позволят задать
цветовой ключ для текстуры, поэтому пришлось прибегнуть к этой. Не обращайте
внимание на обилие параметров - половина из них взята "по умолчанию". Всегда
можно написать собственную промежуточную функцию, и избавить код от захламления
при загрузке множества текстур.
<p>С цветовым ключом мы уже давно знакомы, но здесь есть два нюанса. Первый -
это то, что цветовой ключ один для всей текстуры. Это может вызвать некоторые
неудобства при размещении разных изображений в одной текстуре (что часто и
делается), но они вполне решаемы с помощью какого-нибудь фотошопа. Второй - если
необходимо задать чёрный цветовой ключ, не пишите вместо D3DCOLOR_XRGB( 0, 255,
0 ) просто 0 - это ошибка, т. к. данное значение сигнализирует о том, что
цветовой ключ не требуется. Надо писать именно D3DCOLOR_XRGB( 0, 0, 0 ),или
$FF000000, что то же самое. </p>Если теперь открыть bmp-файл, то сразу видно,
что я разместил там два изображения. Как я уже говорил, размеры текстур должны
равняться степени двойки. Поэтому мы не можем разместить изображение фона в
растре размерностью 512*384, приходится его расширять до 512*512 пикселей. Чтобы
зря не тратить память видеокарты, по возможности необходимо размещать в
свободных участках какие-либо дополнительные изображения. В моём случае влез
рисунок 128*128, хотя его первоначальные размеры были в два раза больше
(пожертвовал для уменьшения архива). Если же нужно вместить что-то
нестандартное, то придётся делать ещё одну текстуру, или расширять существующую,
скажем, до 512*1024. Тут нужно пробовать разные варианты и комбинации, пока не
будет найден какой-то компромисс. Кстати, если уж говорить о размерах текстур,
так вот: Direct3D МОЖЕТ загрузить растр любого размера, но при рендеринге тем
способом, который я собираюсь использовать, возникнут искажения. Этот вопрос
мною ещё слабо изучен, поэтому лучше пока это "на потом", а пока выучить степени
двойки наизусть.
<p>Теперь можно приступать непосредственно к рендерингу изображения. Для
простоты я "завесил" экран одной частью текстуры (кстати, это небезызвестный
кадр из альфа-версии DOOM 3 :). Сверху же будет выводиться спрайт, другая часть
текстуры. </p>Итак, для начала необходимо очистить кадровый буфер и
"скомандовать" GPU начать просчитывать новый кадр:
<pre><font color="#000080"><i>// очищаем кадровый буфер</i></font>
g_device.Clear(0, <b>nil</b>, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0, 0);
<font color="#000080"><i>// начинаем рисовать изображение</i></font>
g_device.BeginScene();
Далее выводим фон:
SetRect(rcTex, 0, 0, 512, 384); <font color="#000080"><i>// область текстуры</i></font>
transv.x := 0; <font color="#000080"><i>// координаты левой</i></font>
transv.y := 0; <font color="#000080"><i>// верхней точки</i></font>
g_pSprite.Draw(g_pTexture, @rcTex, <b>nil</b>, <b>nil</b>, 0, @transv, $FFFFFFFF);</pre>
С методом ID3DXSprite.Draw() надо разобраться.
<pre><b>function</b> Draw(<b>const</b> pSrcTexture: IDirect3DTexture8; pSrcRect: PRect;
pScaling, pRotationCenter: PD3DXVector2; <b>const</b> Rotation: Single;
pTranslation: PD3DXVector2; <b>const</b> Color: TD3DColor): HResult; <b>stdcall</b>;</pre>
Параметром
pSrcTexture передаём наш интерфейс pTexture. PSrcRect - это область текстуры,
которая будет "натягиваться" на полигон, имитирующий наш спрайт. PScaling - это
параметр типа D3DXVECTOR2, задаёт масштабирование спрайта по осям X и Y.
Значение 1.0 задаётся для вывода реальных размеров, при 0.5 произойдет
уменьшение в два раза, при 2.0 - увеличение в два раза. PRotationCenter - это
центр оси поворота. Rotation - это угол поворота в радианах. Т. к. обычно
используюся градусы, необходимо преобразовывать градусную меру в радианную. Я
отыскал вот такую формулу перехода:
<div align="center"><tt>a = 3.14 * n / 180 (радиан)</tt></div>pTranslation -
перенос системы координат, в просторечье позиция левого верхнего угла спрайта.
Color - используется при альфа-прозрачности и при задании цветовых компонент.
Параметр - типа D3DCOLOR, определённого как DWORD. Первые три бита описывают
компоненты RGB, последний - альфа-прозрачность. Для простого отображения
текстуры используется значение $FFFFFFFF. Чтобы понять, как нужно манипулировать
этим значением, попробуйте для фона задать такое: $FF00FF00.
<p>При прорисовке фона мы указываем только область текстуры, позицию левого
верхнего угла и цвет. Остальным параметрам передаём nil. </p>Теперь необходимо
вывести спрайт и закончить рендеринг. Вот тут-то я и показал преимущества
Direct3D над DirectDraw. То, чего нельзя было сделать ранее, можно легко
использовать сейчас:
<pre>SetRect(rcTex, 0, 384, 128, 512); <font color="#000080"><i>// область текстуры</i></font>
transv.x := x - 64 * fScale; <font color="#000080"><i>// координаты левой</i></font>
transv.y := y - 64 * fScale; <font color="#000080"><i>// верхней точки</i></font>
scalev.x := fScale; <font color="#000080"><i>// масштабирование по оси X и</i></font>
scalev.y := fScale; <font color="#000080"><i>// Y</i></font>
rotv.x := 64 * fScale; <font color="#000080"><i>// положение оси</i></font>
rotv.y := 64 * fScale; <font color="#000080"><i>// поворота (здесь центр спрайта)</i></font>
g_pSprite.Draw(g_pTexture, @rcTex, <font color="#000080"><i>// текстура и её область</i></font>
@scalev, <font color="#000080"><i>// масштаб</i></font>
@rotv, <font color="#000080"><i>// позиция оси поворота</i></font>
D3DX_PI * fAngle / 180.0, <font color="#000080"><i>// угол поворота(перевод градуса в радианы)</i></font>
@transv, <font color="#000080"><i>// позиция в окнонных координатах</i></font>
((255 - alpha) <b>shl</b> 24) + $FFFFFF); <font color="#000080"><i>// альфа-прозрачность</i></font>
<font color="#000080"><i>// закончили рисовать изображение</i></font>
g_device.EndScene();
<font color="#000080"><i>// выводим содержимое кадрового буфера на экран</i></font>
g_device.Present(<b>nil</b>, <b>nil</b>, 0, <b>nil</b>);</pre>
<p>Спрайт можно поворачивать клавишами "вправо" и "влево", прозрачность меняется
при нажатии на "вверх" и "вниз", масштабирование происходит при нажатии на "+"
или "-" на основной клавиатуре.</p>
<div align="center"><img alt="" border="0" height="300" src="images/screen.jpg" width="400"></div><br><br>Итак, какие впечатления?
<ol>
<li>При ПРОСТОМ отображении Direct3D рисует картинку, неотличимую от той,
которую мы бы получили при использовании DirectDraw. Отсутствует какая-либо
размытость, или неточность. Это главный плюс.
</li><li>Применение эффектов вроде прозрачности или масштабирования никак не
сказывается на скорости вывода. Оно и понятно - мы же имеем дело с рендерингом
изображения, а не с BitBlt-операциями.
</li><li>При повороте спрайта или его масштабировании применяется билинейная
фильтрация - это сглаживание пикселей изображения, используется для устранения
большой ступенчатости и "переливов" пикселей. К сожалению, здесь я обнаружил
проблему. При повороте спрайта или при изменении масштаба начинают сказываться
ошибки в отображении. Они проявляются в том, что при сглаживании начинают
"захватываться" соседние пиксели текстуры, уже не принадлежащие нашему
изображению. Например, видены "уголки" или тонкая серая полоска справа - там,
где находится граница с пустым белым изображением. Можно только посетовать,
что разработчики алгоритмов фильтрации упростили их до такой степени. Верным
решением было бы задействование только тех пикселей, которые указаны в области
pSrcRect, и не иметь НИКАКИХ дел с теми, что лежат вне её. Единственным
надёжным решением может служить такое: перед размещением разных изображений в
одном залейте его каким-нибудь однотонным цветом, который будет служить
цветовым ключом. После этого размещайте изображения, но так, чтобы между ними
всегда был зазор в 1 пиксель. Это гарантирует отсутствие помех. Понимаю,
накладно, но иного пути не вижу. Всё-таки, наверное, простой алгоритм
фильтрации выполняется на аппаратном уровне гораздо быстрее любого другого
"заумного". Ради скорости и качества, думаю, в графическом редакторе можно и
попотеть. </li></ol><br><br>На последок: раскоментируйте строку
<pre><font color="#000080"><i>//g_device.SetRenderState( D3DRS_FILLMODE, D3DFILL_WIREFRAME );</i></font></pre>
и
добавьте вызовы g_pSprite._Begin() после g_device.Begin() и g_pSprite._End()
перед g_device.End(). Сможете увидеть, из чего состоят "спрайты" :) <br><br>Ну
вот и всё, что нужно при простом использовании Direct3D. Хочется ещё заметить,
что такие спрайты используются не только в 2D-графике, но так же с успехом и при
построении трёхмерных сцен. Например, при выводе HUD. Или вот, в Quake 3 - газы
при стрельбе из Machine Gun'а ни что иное, как спрайт, помещённый перед стволом
и отрисованный с некоторой прозрачностью. В общем, примеров использования
достаточно. Конечно, после практики с интерфейсом ID3DXSprite не лишне
попробовать и более низкоуровневые методы вывода изображения.
<ul>
<li><a href="http://www.delphi-jedi.org/DelphiGraphics/directx/headers/DirectXGraphics.zip">http://www.delphi-jedi.org/DelphiGraphics/directx/headers/DirectXGraphics.zip</a>
- заголовочные файлы для работы с Direct3D.
</li><li><a href="http://www.delphi-jedi.org/DelphiGraphics/directx/headers/DirectXGraphics.zip">http://www.delphi-jedi.org/DelphiGraphics/directx/headers/DirectXGraphics.zip</a>
- все заголовочные файлы для работы с DirectX 8. </li></ul>
<p>Скачать примеры к статье <strong><a href="http://delphi.mtu-net.ru/zip/d3dxsprite.zip">D3DXSprite.zip</a></strong>
(95 K)</p>
Смотрите по теме:
<ul>
<li><strong><a href="http://www.delphikingdom.com/helloworld/directx.htm">DirectX для
начинающих </a></strong>
</li><li><strong><a href="http://www.delphikingdom.com/helloworld/directx_01.htm">DirectX для
начинающих. DirectInput API </a></strong>
</li><li><strong><a href="http://www.delphikingdom.com/helloworld/directx_02.htm">DirectX для
начинающих. Sprite </a>
</strong></li><li><strong><strong><a href="http://www.delphikingdom.com/helloworld/directx_03.htm">DirectX для
начинающих. Sound </a></strong>
</strong></li><li><strong><strong><a href="http://www.delphikingdom.com/helloworld/directx_04.htm">DirectX для
начинающих. Часть третья. Считывание и запись </a></strong>
</strong></li><li><strong><strong><a href="http://www.delphikingdom.com/helloworld/directx4.htm">Полупрозрачные
спрайты в DirectDraw </a></strong>
</strong></li><li><strong><strong><a href="http://www.delphikingdom.com/helloworld/dx_engine.htm">Пишем
DirectX-движок </a></strong>
</strong></li><li><strong><strong><a href="http://www.delphikingdom.com/article/drx.htm">DirectX и
Delphi </a></strong></strong></li></ul><strong>
<br>
<p>Далее: <a href="/delphi/directx_and_delphi.html">DirectX и Delphi</a> »»</p>
<p style="padding:3px;border:1px solid #dddddd;font-size:9px;color:#777777;"></p>
<div style="clear:both">&nbsp;</div>
</strong>
