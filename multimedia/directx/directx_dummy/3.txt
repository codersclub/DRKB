<br><font class="Header">DirectX для начинающих. Часть третья. Считывание и запись</font><hr size="1"><p align="right"><a title="Все публикации автора" class="Bold" href="/asp/users.asp?ID=1146">Виктор Кода</a><br>дата публикации <font class="Brown">15-07-2002 12:50</font></p><div align="right"><hr align="right" size="1" width="25%"><a class="SmallGray" href="/asp/viewitem.asp?catalogid=621&amp;mode=print">Версия для печати</a> <img align="absmiddle" src="/images/system/print.gif" width="20" height="18" border="0" alt="Версия для печати"></div><title>DirectX для начинающих. Часть третья. Считывание и запись </title><p>Привет всем, кто интересуется программированием под DirectX на языке Object Pascal!
</p>
Как и обещал, я продолжаю искать новый материал по DirectX, переводить его на язык Object Pascal и представлять всеобщему вниманию. Недавно у меня появилась идея снятия скриншотов с экрана DirectDraw-программы и записи изображения в простой bmp-файл - некоторые игры позволяют это делать, и я решил последовать их примеру. Потом я наткнулся на другой интересный материал - речь шла о загрузке  изображения из bmp-файла без использования функции LoadImage(). Поэтому тема статьи всецело посвящена работе с bmp-файлами на "низком уровне". Замечу, что это немного сложные вещи, но мы ведь сложностей не боимся, правда? Иначе непонятно, зачем тогда заниматься изучением DirectX вообще.
<p><table width="100%" bgcolor="#FAEBD7" cellpadding="3" cellspacing="0" border="0">
<tbody><tr><td align="CENTER"><font color="#996600"><b>
Замечания</b></font></td></tr></tbody></table></p>
Каждому примеру для нормальной работы необходимо, чтобы файл data.bmp находился в том же каталоге, что и исполняемый файл. Для экономии места в архиве я разместил этот файл в папке первого примера, поэтому вам надо будет скопировать его  и в остальные папки.

<p>Немного изменилась реализация модуля ddutils.pas - теперь функция CreateSurface() не требует адрес главного интерфейса IDirectDraw, а создаёт и уничтожает локальный интерфейс. Возможно, более практично с точки зрения Pascal-программирования было бы объявить глобальный для модуля ddutils.pas интерфейс IDirectDraw, а для создания и удаления интерфейса воспользоваться секциями initialization и finalization модуля.
</p>
Также немного изменился стиль написания программ, теперь он совсем грешит С-подобным кодом :-)
<p><table width="100%" bgcolor="#FAEBD7" cellpadding="3" cellspacing="0" border="0">
<tbody><tr><td align="CENTER"><font color="#996600"><b>
FASTFILE1</b></font></td></tr></tbody></table></p>
В этом примере я попытаюсь показать, как произвести загрузку растра из bmp-файла методом, отличным от того, что применялся в предыдущих уроках. Напомню, как в общих чертах выглядела схема загрузки ранее:

<ol>
	<li>С помощью функции LoadImage() загружался растр и нам сообщался идентификатор загруженного растра в виде переменной типа HBITMAP;</li>
	<li>Функцией SelectObject() в контекст-источник выбирался созданный растр;</li>
	<li>Методом IDirectDrawSurface7.GetDC() создавался GDI-совместимый дескриптор контекста-приёмника и осуществлялась блокировка поверхности;</li>
	<li>Функцией GDI BitBlt() содержимое контекста-источника копировалось на контекст-приёмник.</li>
	<li>Методом IDirectDrawSurface7.ReleseDC() удалялся созданный контекст и осуществлялась разблокировка поверхности.</li>
</ol>
		
В чём недостатки такого подхода? В универсальности. Не скажу, что функция LoadImage() очень медленная, но и очень быстрой она не является. Во всяком случае, программисты, писавшие её, не ставили своей задачей обеспечить максимальную скорость загрузки. Посмотрите справку по этой функции (файл win32sdk.hlp) - обилие параметров и констант, задаваемых при вызове, наводят на мысль о том, что она довольно "тяжеловесна". В частности, сказано, что с её помощью можно загружать не только растры из bmp-файлов разных форматов (в их число входят монохромные, 16- и 256-цветные палитровые файлы, а также беспалитровые 24-битные файлы), но и файлы иконок Windows и даже файлы, содержащие изображения курсоров.

<p>Естественно, всё это отрицательно сказывается на скорости загрузки - метод получается простым, но не самым эффективным. Поэтому часто программисты пишут собственные быстрые функции для загрузки файлов какого-то определённого формата. В этом примере я реализовал отдельную функцию, которая предназначена для загрузки данных из 24-битного беспалитрового файла формата bmp.</p>

Прежде чем приступить к рассмотрению работы функции, необходимо в общих чертах представить себе, каким образом записывается информация в bmp-файле. На рис. 1 показана структура беспалитрового 24-битного файла.
<div align="center"><img src="../images/bmp.gif" width="300" height="108" border="0" alt="Рис.1. Структура файла BMP, не содержащего палитру"><br>
Рис.1. Структура файла BMP, не содержащего палитру</div>														  
Хранящийся на диске файл DIB, обычно с расширением .bmp, как видно, начинается со структуры BITMAPFILEHEADER, позволяющей начать работу с файлом. Вот как эта структура описана в файле windows.pas:
<pre>tagBITMAPFILEHEADER = packed record
  bfType: Word;        <font color="#0000FF">// Тип файла. Должен содержать 'BM' ($4d42)</font>
  bfSize: DWORD;      <font color="#0000FF"> // Размер файла в байтах</font>
  bfReserved1: Word;   <font color="#0000FF">// Зарезервировано, должен быть нуль</font>
  bfReserved2: Word;   <font color="#0000FF">// Зарезервировано, должен быть нуль</font>
  bfOffBits: DWORD;    <font color="#0000FF">// Смещение от начала файла до гафических данных</font>
end;
BITMAPFILEHEADER = tagBITMAPFILEHEADER;
</pre>			 
Следом за структурой BITMAPFILEHEADER следует стуктура BITMAPINFO:

<pre>tagBITMAPINFO = packed record
  bmiHeader: TBitmapInfoHeader;       <font color="#0000FF">// Структура BITMAPINFOHEADER</font>
  bmiColors: array[0..0] of TRGBQuad; <font color="#0000FF">// RGB-триплекс</font>
end; 
BITMAPINFO = tagBITMAPINFO;</pre>
Фактически, стуктура BITMAPINFO включает в себя ещё одну структуру - BITMAPINFOHEADER:
<pre>tagBITMAPINFOHEADER = packed record
  biSize: DWORD;                <font color="#0000FF">// Размер самой структуры в байтах</font>
  biWidth: Longint;             <font color="#0000FF">// Ширина растра в пикселях</font>
  biHeight: Longint;            <font color="#0000FF">// Высота растра в пикселях</font>
  biPlanes: Word;               <font color="#0000FF">// Количество плоскостей (всегда 1)</font>
  biBitCount: Word;             <font color="#0000FF">// Количество бит на 1 пиксель </font>
  biCompression: DWORD;         <font color="#0000FF">// Тип сжатия (BI_RGB - без сжатия)</font> 
  biSizeImage: DWORD;          <font color="#0000FF"> // Размер изображения в байтах (обычно 0)</font>
  biXPelsPerMeter: Longint;     <font color="#0000FF">// А эти данные </font>
  biYPelsPerMeter: Longint;    <font color="#0000FF"> // нам вообще</font>
  biClrUsed: DWORD;             <font color="#0000FF">// никогда не</font>
  biClrImportant: DWORD;        <font color="#0000FF">// понадобятся</font> <font color="#FF0000">:)</font>
end;
BITMAPINFOHEADER = tagBITMAPINFOHEADER;</pre>

Эта структура для нас наиболее интересна, так как опираясь на её данные, и будет производиться загрузка растра. Несмотря на обилие полей, нам понадобятся только некоторые - это biWidth, biHeight и ещё поле biBitCount - для проверки, является ли файл 24-битным.

<p>После этих структур начинаются графические данные. В 24-битном файле каждый пиксель кодируется 3 байтами - на каждую составляющую R, G, B - по одному байту. Значение каждой составляющей может варьироваться от 0 до 255.
</p>
Откройте файл проекта и найдите функцию LoadData(). Она вызывает другую функцию - LoadBitMap(). Я разместил её в файле ddutils.pas, вот её прототип

<pre>function LoadBitMap( name: pchar; pbi: PBITMAPINFO ): pointer;</pre>																		   
Первым параметром передаётся имя загружаемого файла, вторым - адрес структуры BITMAPINFO, структура понадобится после вызова функции LoadBitMap().

<p>Для считывания данных с диска я использую API-функции, предоставляемые ОС, а не библиотечные функции Delphi. Причина - немного более высокое быстродействие, при том, что сами функции просты в обращении и предоставляют некоторые средства контроля при чтении-записи.
</p>
Вот как, например, открывается файл:

<pre>hFile := CreateFile( name, GENERIC_READ, FILE_SHARE_READ, nil,
                     OPEN_EXISTING, 0, 0 );
if hFile = INVALID_HANDLE_VALUE then
   exit;
</pre>		  
Переменная hFile - это дескриптор открытого файла. Проверить, открыт ли он в самом деле можно, сравнив дескриптор с константой INVALID_HANDLE_VALUE. Далее считывается структура BITMAPFILEHEADER:

<pre>ReadFile( hFile, bfh, sizeof( BITMAPFILEHEADER ), dwBytesRead, nil );</pre>																				 
<p>Замечу, что вторым параметром функции ReadFile() передаётся сама структура, куда будут записаны данные, третьим - количество байт, которые надо прочитать. Четвёртые параметр должен присутствовать обязательно, в него функция запишет количество реально прочитанных байт. Для пущей надёжности можно сравнить это значение с размером структуры BITMAPFILEHEADER, и если значения не совпадают, объявить об ошибке.
</p>
Далее считывается структура BITMAPINFOHEADER:

<pre>ReadFile( hFile, bi, sizeof( BITMAPINFOHEADER ), dwBytesRead, nil );</pre>
<p>Думаю, надо объяснить, почему здесь мы читаем только данные структуры BITMAPINFOHEADER, и не считываем массив bmiColors. Дело в том, что этот массив в структуре BITMAPINFO, там, куда мы её передадим позже, всё равно не используется. Однако он входит в состав общих графических данных, поэтому мы считаем его вместе с ними, а в структуре bi массив bmiColors оставим пустым.
</p>
Далее идёт считывание графических данных. Прежде всего необходимо определить, какой размер они имеют:

<pre><font color="#0000FF">// Определяем размер DIB</font>
dwDIBSize := GetFileSize( hFile, nil ) - sizeof( BITMAPFILEHEADER ) - sizeof( BITMAPINFOHEADER );</pre>

То есть от размера bmp-файла отнимаются размеры описанных выше структур. Замечу, что для палитровых файлов придётся учитывать ещё и размер палитры. Далее, выделяется участок в оперативной памяти нужной длины и получается указатель на него:

<pre><font color="#0000FF">// Выделяем участок памяти</font>
result := pbyte(GlobalAllocPtr( GMEM_MOVEABLE, dwDIBSize ));</pre>

После этого в память считываются битовые данные, формирующие картинку, и файл закрывается:
<pre><font color="#0000FF">// Читаем данные DIB</font>
ReadFile( hFile, result^, dwDIBSize, dwBytesRead, nil );
<font color="#0000FF">// Закрываем файл</font>
CloseHandle( hFile );
</pre>		
Описанная функция работает только с 24-битными несжатыми растрами. Использование 256-цветных палитровых файлов я считаю нецелесообразным, т. к. качество изображения в них не удовлетворяет требованиям современной компьтерной графики.

<p>Итак, функция LoadBitMap() загрузила в оперативную память битовые данные, формирующие изображение и вернула указатель на них как результат функции. Вернёмся теперь обратно к функции LoadData(). Первый шаг сделан - произведена максимально быстрая загрузка данных из файла (я не вижу способа, как можно ещё как-нибудь ускорить этот процесс). Теперь надо сделать второй шаг. В чём он состоит? Для ускорения загруки в играх и других программах все графические данные объединяются в один или несколько больших файлов. Такую реализацию, например, можно увидеть в игре Donuts из DirectX SDK 7-8. Такое объединение очень полезно при условии, что файл на жестком диске нефрагментирован. Данный метод, безусловно, уменьшает время загрузки, но как будет видно далее, добавляет лишних хлопот программисту.
</p>
Я подготовил простой bmp-файл, в котором хранится изображение для фона и десять "кадров", которые будут последовательно сменять друг друга. Как же загрузить эти данные на поверхности DirectDraw?
Есть два пути:
<ol>
	<li>Воспользоваться методами Lock() и Unlock() интерфейса IDirectDrawSurface7, и осуществлять прямое копирование данных функцией CopyMemory(). Это решение оптимально по скоростным характеристикам, но уж очень сложное: необходимо учитывать абсолютно все нюансы формата поверхности, на которую копируются данные - а их очень много, ведь формат меняется в зависимости от глубины цвета текущего видеорежима - 8, 16, 24, 32 бит. К тому же, выигрыш в этом случае может оказаться совсем небольшим. </li>
	<li>Использовать функцию GDI StretchDIBits(). Она предназначена для копирования в контекст данных, расположеных не в другом контексте, а находящихся просто в указаннном участке памяти. Может сложиться впечатление, что эта функция достаточно медленна - из-за угрожающей приставки "Stretch". Однако если будут копироваться участки битов, одинаковые по высоте и ширине, то в этом случае функция, думается, должна работать быстрее.</li>
</ol>
Я решил использовать второй способ. 
Итак, первым делом создадим поверхность для фона:

<pre>CreateSurface( g_pWallpaper, 640, 480 );</pre>
После этого получим контекст для поверхности и осуществим копирование функцией StretchDIBits(). В файле справки о методе IDirectDrawSurface7.GetDC() сказано, что он является надмножеством над методом IDirectDrawSurface7.Lock() - т. е. осуществляет те же операции, которые мы бы проделали при прямом копировании данных. Различие в том, что здесь DirectDraw учитывает особенности формата поверхности при создании контекста-приёмника. Думаю, нет необходимости дублировать эти операции - выигрыш в скорости может оказаться весьма сомнительным, т.к. код в библиотеке DirectDraw и без того максимально быстр.

<pre>if g_pWallpaper.GetDC( DC ) = DD_OK then
  begin
<font color="#0000FF">// Копируем битовый массив в контекст</font>
    StretchDIBits( DC,
                   0, 0, 640, 480,
                   0, 64, 640, 480,
                   pBits, bi,
                   0, SRCCOPY );
    g_pWallpaper.ReleaseDC( DC );
  end;</pre>			  
<p>  Заметьте, что растр в файле (и памяти) хранится в перевёрнутом виде, поэтому ось Y битовой карты направлена вверх. Это необходимо учитывать при задании области копирования. Для копирования массива битов функции StretchDIBits() необходимо передать адрес массива в памяти, а также адрес структуры BITMAPINFO - опираясь на неё, она сможет правильно произвести копирование.
</p>
Далее  10 раз осуществляется копирование в отдельные поверхности массива g_pMovie. Опять же, необходимо учитывать, что строки растра перевёрнуты. После этого необходимо освободить участок системной памяти, где хранится битовый массив:

<pre><font color="#0000FF">// Освободили битовый массив!</font>
pBits := nil;</pre>
Вот и всё, можно приступать к отрисовке экрана.

<p>Вообще такая схема объединения всех данных в один большой или несколько больших файлов оправдана в крупных программах и играх - там, где набор различных изображений достигает сотен штук. На этапе черновой разработки целесообразно загружать растры из отдельных файлов, а в конце, перед релизом программы, в процессе доводки и оптимизации, объединить всё в один большой файл. При этом придётся немного поработать в графическом редакторе, разместив отдельные растры оптимальным способом, не оставляя "пустых" мест. Также целесообразно подготовить массив типа TRect, которыи будет описывать область каждой картинки в этом растре, и пользоваться им в функции загрузки.
</p>
<p><table width="100%" bgcolor="#FAEBD7" cellpadding="3" cellspacing="0" border="0">
<tbody><tr><td align="CENTER"><font color="#996600"><b>
FASTFILE2</b></font></td></tr></tbody></table></p>
Предыдущий пример продемонстрировал способ ускорить загрузку файла в память. Однако перенос данных на конкретные поверхности усложнился, да и постоянный вызов функции StretchDIBits() должен отрица-
тельно сказаться на времени копирования.

<p>Чтобы не копировать каждый раз содержимое нового участка памяти на отдельную поверхность DirectDraw функцией StretchDIBits(), я решил все данные из памяти скопировать на одну большую поверхность DirectDraw, а потом копировать её содержимое по участкам на другие поверхности методом IDirectDrawSurface7.BltFast(). Казалось бы, такое двойное копирование - из памяти на общую поверхность, а потом с этой поверхности на отдельные поверхности - довольно долгий процесс. Однако если память видеокарты достаточно большая (32-64 Мб), можно позволить программе разместить все созданные поверхности в памяти видеокарты, и тогда копирование методом IDirectDrawSurface7.BltFast() будет происходить очень быстро. При большом объёме графических данных этот способ предпочтителен. К тому же данные на общей поверхности DirectDraw хранятся в нормальном, а не перевёрнутом виде, что облегчает программисту перенос.
</p>
Этот способ и демонстрирует данный проект. Всё остальное осталось без изменений.

<p>Наконец, существует ещё один, наиболее эффективный путь. Можно не заниматься копированием растра с общей на отдельные поверхности, а переносить растр на дополнительный буфер прямо с общей поверхности.</p>
Например:
<pre>g_pBackBuffer.BltFast( x, y, g_pMovie[ frame ], nil, DDBLTFAST_WAIT );</pre>
Однако можно третьим параметром указать общую data-поверхность, а четвертым - не nil, а область на этой поверхности:

<pre>g_pBackBuffer.BltFast( x, y, g_pDataSurface, arrayRect[ FRAME_01 ], DDBLTFAST_WAIT );</pre>
Тогда можно не создавать отдельные поверхности и не заниматься копированием данных. Однако есть и недостатки. Например, память видеокарты должна быть достаточно большой - если памяти не хватит для размещения всей data-поверхности, DirectDraw разместит её в системной памяти, и процесс вывода изображения резко замедлится - вот вам и оптимизация! Также могут возникнуть проблемы с цветовыми ключами и корректным отображением спрайтов. В общем, решение половинчатое.
<p><table width="100%" bgcolor="#FAEBD7" cellpadding="3" cellspacing="0" border="0">
<tbody><tr><td align="CENTER"><font color="#996600"><b>
PRINTSCREEN</b></font></td></tr></tbody></table></p>
Заманчиво, когда в программе имеется возможность делать "снимки" экрана и сразу записывать их в файл.  Этот пример ничем не отличается от предыдущих, за исключением того, что при нажатии на клавишу "Пробел" делается запись содержимого экрана в файл screen.bmp. 

<p>Функция, которая проделывает эту работу, находится в файле pscreen.pas. Рассмотрим её.
</p>
Первым делом создаётся новый файл или открывается для перезаписи старый:
<pre><font color="#0000FF">// создаём файл с заданным именем, в него будет производиться запись</font>
hFile := CreateFile( szFileName, GENERIC_WRITE, FILE_SHARE_READ, nil, CREATE_ALWAYS, 0, 0 );
if hFile = INVALID_HANDLE_VALUE then
begin
  CloseHandle( hFile );
  exit;
end;</pre>
Затем нам необходимо получить данные о поверхности (здесь в функцию передан дополнительный буфер):
<pre><font color="#0000FF">// подготавливаем структуру TDDSURFACEDESC2</font>
ZeroMemory( @ddsd2, sizeof( TDDSURFACEDESC2 ) );
ddsd2.dwSize := sizeof( TDDSURFACEDESC2 );

<font color="#0000FF">// получаем формат поверхности</font>
pSurface.GetSurfaceDesc( ddsd2 );
dwWidth  := ddsd2.dwWidth;
dwHeight := ddsd2.dwHeight;
dwBPP    := ddsd2.ddpfPixelFormat.dwRGBBitCount;
</pre>			
Структура ddsd2 используется дополнительно в методе Lock() поверхности. Заблокировав поверхность, можно обратится к её содержимому для чтения данных:

<pre><font color="#0000FF">// блокируем поверхность DirectDraw</font>
if( FAILED( pSurface.Lock( nil, ddsd2, DDLOCK_WAIT, 0 ) ) ) then
    exit;
</pre>																	 
Затем необходимо выделить достаточное количество памяти под массив пикселей. Число три в конце выражения - это потому, что вывод будет осуществляться в 24-битный файл:

<pre>pPixels := pbyte(GlobalAllocPtr( GMEM_MOVEABLE, dwWidth * dwHeight * 3 ));</pre>
Затем начинается главное. Т. к. формат пикселя поверхности в каждом из графических режимов различается, необходимо предусмотреть все особенности размещения данных. Бессмысленно подробно описывать все операции - они запутанны и сложны. Мне понадобилось некоторое количество времени, чтобы правильно перевести все операции с указателями с языка C++ в контекст Object Pascal. Операции с указателями на этом языке получаются довольно путаными, малейшая оплошность приводит к тому, что обычно в файл записывается не тот участок памяти (получается мешанина из пикселей), или запись вообще не происходит. Обратите внимание на такую строку:
<pre>pixel := PDWORD(DWORD(ddsd2.lpSurface) + i * 4 + j * ddsd2.lPitch)^;</pre>
Здесь определяется цвет нового пикселя поверхности. ddsd2.lpSurface - это указатель на начало данных поверхности, а ddsd2.lPitch - шаг поверхности, учитывать его нужно обязательно.

<p>После того, как данные скопированы в массив, поверхность обязательно нужно разблокировать. Теперь можно начать запись данных в файл.
</p>
Для начала необходимо вручную подготовить структуры BITMAPFILEHEADER и BITMAPINFOHEADER. В последней надо указать ширину и высоту растра, а также разрядность пикселя. Тип сжатия должен быть BI_RGB - т. е. без сжатия.

<p>После этого с помощью API-функций Windows последовательно в файл записываются структуры BITMAPFILEHEADER, BITMAPINFOHEADER и далее - подготовленные данные из памяти. После записи файл необходимо закрыть, а память - освободить:
</p>
<pre><font color="#0000FF">// закрываем файл</font>
CloseHandle( hFile );
pPixels := nil;												   
</pre>																   
Функция получилась громоздкой, согласен. Однако иного способа не существует - во всём виноват формат поверхности. Кстати, я не учёл режим в 256 цветов - опять же по причине анахронизма.

<p>И последнее. Данная функция работает не совсем корректно - если открыть созданный файл в графическом редакторе, то под большим увеличением можно заметить ма-аленький цветовой артефакт - один стобик пикселей имеет не тот цвет. Решение этой проблемы я так и не смог найти.
</p>		  
Скачать примеры: <strong><a href="http://www.delphikingdom.com/zip/directx3.zip">DirectX3.zip</a></strong> (95K)
<p align="right"><a href="../asp/users.asp?ID=1146"><strong>Виктор Кода</strong></a><br>
Специально для <a href="http://www.delphikingdom.com"><b>Королевства Delphi</b></a></p>

<br><br><br><font class="SubHeader">Смотрите также материалы по темам:</font><hr size="1"> [<a class="SmallGray" href="/asp/itemq.asp?mode=1&amp;itemid=206">DirectX, DirectShow etc.</a>]<br><br><img align="absmiddle" src="../images/system/pencil.gif" width="16" height="16" border="0">&nbsp;<a class="Bold" href="/asp/articles_forum.asp?ArticleID=621">Обсуждение материала</a> [ <font class="Brown">11-04-2009 14:14</font> ] 1 сообщение
