---
Title: Работа с большими массивами
Date: 01.01.2007
---


Работа с большими массивами
===========================

Вариант 1:

Source: Советы по Delphi от [Валентина Озерова](mailto:webmaster@webinspector.com) Сборник Kuliba

Распределите память кучи с помощью GetMem. Если вы имеете:

    var a, b: array[0..30000]: Integer;

то попробуйте:

    type  TBigArray = array[0..30000] of Integer;
    var  a, b: ^TBigArray;

и во внешнем блоке сделайте:

    GetMem(a, SizeOf(TBigArray));
    GetMem(b, SizeOf(TBigArray));

Также необходимо применять указатели на память вместо ссылок, например
взамен:

    a[0] := xxx; 

необходимо использовать

    a^[0] := xxx; 

------------------------------------------------------------------------

Вариант 2:

Source: DelphiWorld 6.0 <https://delphiworld.narod.ru/>

Заставить Delphi работать с достаточно большим массивом данных

    procedure TForm1.Button1Click(Sender: TObject);
      type
        TMyRec = record
        i1, i2, i3: Integer;
      end;
      TMyArr = array[1..20000000] of TMyRec;
      PMyArr=^TMyArr;
    var
      A: PMyArr;
    begin
      GetMem(A, SizeOf(TMyArr));
      A^[1].i1 := 100;
      ShowMessage('Ok' + IntToStr(A^[1].i1));
      FreeMem(A);
    end;


------------------------------------------------------------------------

Вариант 3:

Source: DelphiWorld 6.0 <https://delphiworld.narod.ru/>

В 16-битной версии Delphi нельзя сделать это непосредственно. В новой,
32-битной версии, это как-то можно сделать, но за два месяца колупания я
так и не понял как. (Некоторые бета-тестеры знают как. Не могли бы они
сообщить нам всю подноготную этого дела?)

В 16-битной версии Delphi вам необходимо работать с блоками по 32K или
64K и картой. Вы могли бы сделать приблизительно следующее:

    type
    chunk:     array[0..32767] of byte;
    pchunk:    ^chunk;
     
    var
    BigArray:  array[0..31] of pChunk;

Для создания массива:

    for i := 0 to high(bigArray) do
      new(bigArray[i]);

Для получения доступа к n-ному байту в пределах массива (n должен иметь
тип longint):

    bigArray[n shr 15]^[n and $7FFF] := y;
    x := bigArray[n shr 15]^[n and $7fff];

Это даже осуществляет проверку выхода за границы диапазона, если вы
установили в ваших настройках опцию "range checking"!

n должен находиться в диапазоне

    [0..32*32*1024] = [0..1024*1024] = [0..1048576].

Для освобождения массива после его использования необходимо сделать
следующее:

    for i := 0 to high(bigArray) do
      dispose (bigArray[i]);




---

**Примечание от Vit:**

проблемы с большими массивами были актуальны в 16-битных средах
(DOS, Windows 3x), когда использовалась сегментированная
модель памяти и было затруднительно напрямую адресовать блоки больее
64K.

В 32-разрядных системах подобные проблемы возникают значительно
реже, при размерах массивов превосходящих 2Gb, что согласитесь даже в
современном программировании дело далеко не частое. Для адресации более
2Gb см. статьи по AWE для 32 разрядных систем.
